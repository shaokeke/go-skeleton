/*
 Navicat Premium Data Transfer

 Source Server         : localhost_3306
 Source Server Type    : MySQL
 Source Server Version : 80012 (8.0.12)
 Source Host           : localhost:3306
 Source Schema         : nest_admin

 Target Server Type    : MySQL
 Target Server Version : 80012 (8.0.12)
 File Encoding         : 65001

 Date: 23/04/2024 17:33:52
*/

SET NAMES utf8mb4;
SET FOREIGN_KEY_CHECKS = 0;

-- ----------------------------
-- Table structure for article
-- ----------------------------
DROP TABLE IF EXISTS `article`;
CREATE TABLE `article`  (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `title` varchar(128) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL,
  `content` text CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL,
  `path` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL,
  `visitCount` int(11) NULL DEFAULT 0,
  `created_at` datetime(6) NOT NULL DEFAULT CURRENT_TIMESTAMP(6),
  `updated_at` datetime(6) NOT NULL DEFAULT CURRENT_TIMESTAMP(6) ON UPDATE CURRENT_TIMESTAMP(6),
  `deletedAt` datetime(6) NULL DEFAULT NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 13 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of article
-- ----------------------------
INSERT INTO `article` VALUES (1, 'guitool0527', 'title: 基于GUI的外挂工具应用开发流程\r\nauthor: gaiaxis\r\ndate: 2020-05-27 19:28:29\r\ntags:\r\n---\r\n# 基于GUI的外挂工具应用开发流程\r\n2020-05-28 01:36:29 星期四\r\n\r\nXScope支持以统一的方式管理各种处理工具，需遵循以下开发流程，即可在系统启动时自动加载到菜单列表中。\r\n## 新建一个类，继承自mImGuiTooler\r\n## 重载RenderUI，开发相关功能\r\n写界面内容即可，工具默认都以model对话框显示，这里无须考虑关闭结束等操作。\r\n\r\n<!--more-->\r\n\r\n## 注册该工具\r\n有两种方式，一种在插件中完成，可以写在IPlugin类里面以插件的方式自动加载，也可以在系统启动时执行，建议用插件自动注册避免重复添加，如：\r\n\r\n`ImGuiToolBox.Insatance.RegeditRootTooler(new tGeoImagePyramidTileCreator());`\r\n\r\n4.系统菜单中添加拓展工具菜单，会自动在这里以菜单的方式显示各种工具。如\r\n```csharp\r\n    if (ImGui.BeginMenu(\"文件\"))\r\n    {\r\n         ImGui.EndMenu();\r\n    }\r\n    ImGuiToolBox.Insatance.DrawRoolToolBoxMenuBar();\r\n    if (ImGui.BeginMenu(\"帮助\"))\r\n    {\r\n       ImGui.EndMenu();\r\n    }\r\n```\r\n\r\n**以下为批量将GIF转换VGI渲染对象的工具。**\r\n\r\n![upload successful](/images/pasted-13.png)\r\n\r\n  ```csharp\r\n public class tPathGIFToVGISheetItemMaker : mImGuiTooler\r\n    {\r\n        private string RootPath = System.Windows.Forms.Application.StartupPath;\r\n        private string mInfo = \"\";\r\n        public tPathGIFToVGISheetItemMaker()\r\n        {\r\n            this.m_Name = \"批量生成GIF的VGI文件\";\r\n            this.RootPath = Gaiaxis.Consoles.Root.Instance.WorldSettings.CachePath;\r\n            this.mInfo = \"将文件夹的GIF图片批量生成VGI文件，默认位置居中，如需改变显示位置，请自行编辑\";\r\n        }\r\n        public override void RenderUI()\r\n        {\r\n            ImGui.InputText(\"文件夹目录\", ref this.RootPath, 256, ImGuiInputTextFlags.ReadOnly);\r\n            ImGui.SameLine();\r\n            if (ImGui.Button(\"设置路径\"))\r\n            {\r\n                ImGuiPickFolderBrowser.Instance.ShowPopupModal(this.RootPath, (s) => { this.RootPath = s; });\r\n            }\r\n            ImGuiPickFolderBrowser.Instance.DrawPopup();\r\n\r\n            ImGui.Spacing();\r\n            ImGui.Text(this.mInfo);\r\n            ImGui.Spacing();\r\n            if (ImGui.Button(\"批量创建\"))\r\n            {\r\n                this.Process();\r\n            }\r\n            ImGui.SameLine();\r\n            if (ImGui.Button(\"打开目录\"))\r\n            {\r\n                this.OpenProcess();\r\n            }\r\n        }\r\n        private void OpenProcess()\r\n        {\r\n            if (string.IsNullOrEmpty(this.RootPath))\r\n            {\r\n                return;\r\n            }\r\n            if (!Directory.Exists(this.RootPath))\r\n            {\r\n                return;\r\n            }\r\n            System.Diagnostics.Process.Start(this.RootPath);\r\n        }\r\n        private void Process()\r\n        {\r\n            if (string.IsNullOrEmpty(this.RootPath))\r\n            {\r\n                return;\r\n            }\r\n            if (!Directory.Exists(this.RootPath))\r\n            {\r\n                return;\r\n            }\r\n            DirectoryInfo dd = new DirectoryInfo(this.RootPath);\r\n            var giffile = dd.GetFiles(\"*.gif\", SearchOption.TopDirectoryOnly);\r\n\r\n            foreach (var item in giffile)\r\n            {\r\n                string name = System.IO.Path.GetFileNameWithoutExtension(item.FullName);\r\n                string xmlname = System.IO.Path.Combine(this.RootPath, name + \".vgi\");\r\n                XScreenAnamationImageRenderDescription des = new XScreenAnamationImageRenderDescription();\r\n                des.Name = name;\r\n                des.GifImagename = item.FullName;\r\n                des.XYWH = new Defines.RegionSize(0.2f, 0.2f, 0.6f, 0.6f);\r\n                des.Save(xmlname);\r\n            }\r\n        }\r\n    }\r\n```', NULL, 0, '2020-05-27 19:28:29.000000', '2024-04-09 13:51:56.190518', NULL);
INSERT INTO `article` VALUES (2, 'hello-world', '---\r\ntitle: Hello World\r\n---\r\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\r\n\r\n## Quick Start\r\n\r\n### Create a new post\r\n\r\n``` bash\r\n$ hexo new \"My New Post\"\r\n```\r\n\r\nMore info: [Writing](https://hexo.io/docs/writing.html)\r\n\r\n### Run server\r\n\r\n``` bash\r\n$ hexo server\r\n```\r\n\r\nMore info: [Server](https://hexo.io/docs/server.html)\r\n\r\n### Generate static files\r\n\r\n``` bash\r\n$ hexo generate\r\n```\r\n\r\nMore info: [Generating](https://hexo.io/docs/generating.html)\r\n\r\n### Deploy to remote sites\r\n\r\n``` bash\r\n$ hexo deploy\r\n```\r\n\r\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\r\n', NULL, 0, '2024-04-09 13:51:56.190518', '2024-04-09 13:51:56.190518', NULL);
INSERT INTO `article` VALUES (3, 'Libraryconfuse', 'title: Product Native Library Code Confuser Steps\r\nauthor: gaiaxis\r\ndate: 2020-12-17 13:35:00\r\ntags:\r\n---\r\n1.	Open Confuser Tool\r\n2.	New or Open Project\r\n3.	In Project tabpage,Set Base Dictionary，Output Directory will be Auto Fitted！\r\n4.	In Project tabpage,Add Library (C# and unconfused)\r\n5.	In Setting tabpage,on Global settting item,Add a rule,In Rule Editor,Set Preset Combox as Normal State ,it’s ok!\r\n6.	In Protect! Tabpage,Do Protected! Success!\r\n7.	Save current project\r\n8.	Copy output Directory Library To ExecuteDirectory.\r\n9.	Done\r\n10.	Tool Download From URL: https://github.com/yck1509/ConfuserEx/releases/tag/v1.0.0', NULL, 0, '2020-12-17 13:35:00.000000', '2024-04-09 13:51:56.190518', NULL);
INSERT INTO `article` VALUES (4, 'localhost和127.0.0.1的区别是什么？', '今天在网上逛的时候看到一个问题，没想到大家讨论的很热烈，就是标题中这个：\nlocalhost 和 127.0.0.1 的区别是什么？\n\n前端同学本地调试的时候，应该没少和 localhost 打交道吧，只需要执行 npm run 就能在浏览器中打开你的页面窗口，地址栏显示的就是这个 http://localhost:xxx/index.html\n可能大家只是用，也没有去想过这个问题。\n联想到我之前合作过的一些开发同学对它们俩的区别也没什么概念，所以我觉得有必要普及下。\nlocalhost 是什么呢？\n\n<!-- more -->\n\nlocalhost 是一个域名，和大家上网使用的域名没有什么本质区别，就是方便记忆。\n只是这个 localhost 的有效范围只有本机，看名字也能知道：local 就是本地的意思。\n张三和李四都可以在各自的机器上使用 localhost，但获取到的也是各自的页面内容，不会相互打架。\n从域名到程序\n要想真正的认清楚 localhost，我们还得从用户是如何通过域名访问到程序说起。\n以访问百度为例。\n1、当我们在浏览器输入 baidu.com 之后，浏览器首先去 DNS 中查询 baidu.com 的 IP 地址。\n为什么需要 IP 地址呢？打个比方，有个人要寄快递到你的公司，快递单上会填写：公司的通讯地址、公司名称、收件人等信息，实际运输时快递会根据通信地址进行层层转发，最终送到收件人的手中。网络通讯也是类似的，其中域名就像公司名称，IP 地址就像通信地址，在网络的世界中只有通过 IP 地址才能找到对应的程序。\nDNS 就像一个公司黄页，其中记录着每个域名对应的 IP 地址，当然也有一些域名可能没做登记，就找不到对应的 IP 地址，还有一些域名可能会对应多个 IP 地址，DNS 会按照规则自动返回一个。我们购买了域名之后，一般域名服务商会提供一个域名解析的功能，就是把域名和对应的 IP 地址登记到 DNS 中。\n这里的 IP 地址从哪里获取呢？每台上网的电脑都会有 1 个 IP 地址，但是个人电脑的 IP 地址一般是不行的，个人电脑的 IP 地址只适合内网定位，就像你公司内部的第几栋第几层，公司内部人明白，但是直接发给别人，别人是找不到你的。如果你要对外部提供服务，比如百度这种，你就得有公网的 IP 地址，这个 IP 地址一般由网络服务运营商提供，比如你们公司使用联通上网，那就可以让联通给你分配一个公网 IP 地址，绑定到你们公司的网关服务器上，网关服务器就像电话总机，公司内部的所有网络通信都要通过它，然后再在网关上设置转发规则，将网络请求转发到提供网络服务的机器上。\n2、有了 IP 地址之后，浏览器就会向这个 IP 地址发起请求，通过操作系统打包成 IP 请求包，然后发送到网络上。网络传输有一套完整的路由协议，它会根据你提供的 IP 地址，经过路由器的层层转发，最终抵达绑定该 IP 的计算机。\n3、计算机上可能部署了多个网络应用程序，这个请求应该发给哪个程序呢？这里有一个端口的概念，每个网络应用程序启动的时候可以绑定一个或多个端口，不同的网络应用程序绑定的端口不能重复，再次绑定时会提示端口被占用。通过在请求中指定端口，就可以将消息发送到正确的网络处理程序。\n但是我们访问百度的时候没有输入端口啊？这是因为默认不输入就使用 80 和 443 端口，http 使用 80，https 使用 443。我们在启动网络程序的时候一定要绑定一个端口的，当然有些框架会自动选择一个计算机上未使用的端口。\n\nlocalhost 和 127.0.0.1 的区别是什么？\n有了上边的知识储备，我们就可以很轻松的搞懂这个问题了。\nlocalhost 是域名，上文已经说过了。\n127.0.0.1 呢？是 IP 地址，当前机器的本地 IP 地址，且只能在本机使用，你的计算机不联网也可以用这个 IP 地址，就是为了方便开发测试网络程序的。我们调试时启动的程序就是绑定到这个 IP 地址的。\n这里简单说下，我们经常看到的 IP 地址一般都是类似 X.X.X.X 的格式，用\".\"分成四段。其实它是一个 32 位的二进制数，分成四段后，每一段是 8 位，然后每一段再转换为 10 进制的数进行显示。\n那 localhost 是怎么解析到 127.0.0.1 的呢？经过 DNS 了吗？没有。每台计算机都可以使用 localhost 和 127.0.0.1，这没办法让 DNS 来做解析。\n那就让每台计算机自己解决了。每台计算机上都有一个 host 文件，其中写死了一些 DNS 解析规则，就包括 localhost 到 127.0.0.1 的解析规则，这是一个约定俗成的规则。\n如果你不想用 localhost，那也可以，随便起个名字，比如 wodehost，也解析到 127.0.0.1 就行了。\n甚至你想使用 baidu.com 也完全可以，只是只能自己自嗨，对别人完全没有影响。\n域名的等级划分\nlocalhost 不太像我们平常使用的域名，比如 www.juejin.cn 、baidu.com、csdn.net, 这里边的 www、cn、com、net 都是什么意思？localhost 为什么不需要？\n域名其实是分等级的，按照等级可以划分为顶级域名、二级域名和三级域名...\n顶级域名（TLD）：顶级域名是域名系统中最高级别的域名。它位于域名的最右边，通常由几个字母组成。顶级域名分为两种类型：通用顶级域名和国家顶级域名。常见的通用顶级域名包括表示工商企业的.com、表示网络提供商的.net、表示非盈利组织的.org 等，而国家顶级域名则代表特定的国家或地区，如.cn 代表中国、.uk 代表英国等。\n二级域名（SLD）：二级域名是在顶级域名之下的一级域名。它是由注册人自行选择和注册的，可以是个性化的、易于记忆的名称。例如，juejin.cn 就是二级域名。我们平常能够申请到的也是这种。目前来说申请 xxx.com、xxx.net、xxx.cn 等等域名，其实大家不太关心其顶级域名 com\\net\\cn 代表的含义，看着简短好记是主要诉求。\n三级域名（3LD）：三级域名是在二级域名之下的一级域名。它通常用于指向特定的服务器或子网。例如，在 blog.example.com 中，blog 就是三级域名。www 是最常见的三级域名，用于代表网站的主页或主站点，不过这只是某种流行习惯，目前很多网站都推荐直接使用二级域名访问了。\n域名级别还可以进一步细分，大家可以看看企业微信开放平台这个域名：developer.work.weixin.qq.com，com 代表商业，qq 代表腾讯，weixin 代表微信，work 代表企业微信，developer 代表开发者。这种逐层递进的方式有利于域名的分配管理。\n按照上边的等级定义，我们可以说 localhost 是一个顶级域名，只不过它是保留的顶级域，其唯一目的是用于访问当前计算机。\n多网站共用一个 IP 和端口\n上边我们说不同的网络程序不能使用相同的端口，其实是有办法突破的。\n以前个人博客比较火的时候，大家都喜欢买个虚拟主机，然后部署个开源的博客程序，抒发一下自己的感情。为了挣钱，虚拟主机的服务商会在一台计算机上分配 N 多个虚拟主机，大家使用各自的域名和默认的 80 端口进行访问，也都相安无事。这是怎么做到的呢？\n如果你有使用 Nginx、Apache 或者 IIS 等 Web 服务器的相关经验，你可能会接触到主机头这个概念。主机头其实就是一个域名，通过设置主机头，我们的程序就可以共用 1 个网络端口。\n首先在 Nginx 等 Web 程序中部署网站时，我们会进行一些配置，此时在主机头中写入网站要使用的域名。\n然后 Nginx 等 Web 服务器启动的时候，会把 80 端口占为己有。\n然后当某个网站的请求到达 Nginx 的 80 端口时，它会根据请求中携带的域名找到配置了对应主机头的网络程序。\n然后再转发到这个网络程序，如果网络程序还没有启动，Nginx 会把它拉起来。\n私有 IP 地址\n除了 127.0.0.1，其实还有很多私有 IP 地址，比如常见的 192.168.x.x。这些私有 IP 地址大部分都是为了在局域网内使用而预留的，因为给每台计算机都分配一个独立的 IP 不太够用，所以只要局域网内不冲突，大家就可劲的用吧。你公司可以用 192.168.1.1，我公司也可以用 192.168.1.1，但是如果你要访问我，就得通过公网 IP 进行转发。\n大家常用的 IPv4 私有 IP 地址段分为三类：\nA 类：从 10.0.0.0 至 10.255.255.255\nB 类：从 172.16.0.0 至 172.31.255.255\nC 类：从 192.168.0.0 至 192.168.255.255。\n这些私有 IP 地址仅供局域网内部使用，不能在公网上使用。\n--\n除了上述三个私有的 IPv4 地址段外，还有一些保留的 IPv4 地址段：\n用于本地回环测试的 127.0.0.0 至 127.255.255.255 地址段，其中就包括题目中的 127.0.0.1，如果你喜欢也可以给自己分配一个 127.0.0.2 的 IP 地址，效果和 127.0.0.1 一样。\n用于局域网内部的 169.254.0.0 至 169.254.255.255 地址段，这个很少接触到，如果你的电脑连局域网都上不去，可能会看到这个 IP 地址，它是临时分配的一个局域网地址。\n这些地址段也都不能在公网上使用。\n--\n近年来，还有一个现象，就是你家里或者公司里上网时，光猫或者路由器对外的 IPv4 地址也不是公网 IP 了，这时候获得的可能是一个类似 100.64.x.x 的地址，这是因为随着宽带的普及，运营商手里的公网 IP 也不够了，所以运营商又加了一层局域网，而 100.64.0.0 这个网段是专门分给运营商做局域网用的。如果你使用阿里云等公有云，一些云产品的 IP 地址也可能是这个，这是为了将客户的私有网段和公有云厂商的私有网段进行有效的区分。\n--\n其实还有一些不常见的专用 IPv4 地址段，完整的 IP 地址段定义可以看这里：www.iana.org/assignments…\n\nIPv6\n你可能也听说过 IPv6，因为 IPv4 可分配的地址太少了，不够用，使用 IPv6 甚至可以为地球上的每一粒沙子分配一个 IP。只是喊了很多年，大家还是喜欢用 IPv4，这里边原因很多，这里就不多谈了。\nIPv6 地址类似：XXXX:XXXX:XXXX:XXXX:XXXX:XXXX:XXXX:XXXX\n它是 128 位的，用\":\"分成 8 段，每个 X 是一个 16 进制数（取值范围：0-F），IPv6 地址空间相对于 IPv4 地址有了极大的扩充。比如：2001:0db8:3c4d:0015:0000:0000:1a2f:1a2b 就是一个有效的 IPv6 地址。\n关于 IPv6 这里就不多说了，有兴趣的可以再去研究下。\n关注萤火架构，加速技术提升！\n\n作者：萤火架构\n链接：https://juejin.cn/post/7321049446443417638\n来源：稀土掘金\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。', NULL, 0, '2024-04-09 13:51:56.190518', '2024-04-09 14:06:59.000000', NULL);
INSERT INTO `article` VALUES (5, 'new-article', 'title: XScope时空大数据可视化分析平台\r\ntags:\r\n  - xscope\r\ncategories:\r\n  - 产品介绍\r\nauthor: mingrz\r\ndate: 2020-05-11 10:22:00\r\n---\r\n**XSCOPE时空大数据可视化分析平台**（简称XSCOPE）自2012年发布以来，由于其特有的基于GPU的大规模数据实时渲染机制，多屏信息共享、多视图协同交互技术，多源空间数据管理技术以及专业的空间分析挖掘能力，让XSCOPE备受用户们的青睐。经过多年的技术积累，基于XSCOPE时空大数据可视化平台核心技术，公司现已经开发出一系列成熟的软件产品，包括XPLATO空间信息可视化平台、装备仿真评估可视化分析平台、智能配电网综合可视化服务平台、洪水分析系列软件系统、全球航运大数据实时可视化管理分析平台、单车历史轨迹可视化展示系统以及系列相关配套的辅助工具等，产品应用于航天航空、水利电力、国防军事、智慧城市等领域，并且在各领域的都积累了许多成功案例与良好口碑，同时也检验了XSCOPE作为通用平台级别在二次开发上的普适性、灵活性和稳定性。\r\n\r\n![upload successful](/blog/images/pasted-2.png)\r\n------------\r\n <!-- more -->\r\n#### 技术特点\r\n \r\n1. 完全独立设计的时空可视化引擎，XSCOPE在各种开源技术和丰富计算机图形渲染资源的基础上，融合了各种平台引擎的技术理念，完全从底层重新架构，为时空大数据应用提供了一套可行的解决方案。融合了GIS平台针对空间数据的全套管理方法，包括数据的输入、管理、编辑、选取、显示、空间分析、投影处理、输出统计等，支持专业的空间拓扑运算和空间分析，支持多重空间对象的可视化表达。可完全支持地理信息系统平台方向的定制开发，是一套标准的GIS引擎。\r\n2. 全球首款纯3D图形化交互的3DGIS平台，拥有游戏级别的深度人机交互体验，XSCOPE完全采用酷炫的游戏化设计风格，融合应用模式、视窗、场景、时空对象、UI于一体，重新定义了空间信息软件设计模式，让专业软件变得更为简单易用，大大提升了空间信息的表达输出效果和人机交互的体验，融入和各种屏幕呈现的图表渲染资源，在技术上完全支持设计作品的程序系统化实现，大大提升了设计和产品之间的转换能力。\r\n3. 支持大规模的实时时空数据渲染呈现，XSCOPE专业为时空大数据而设计，所有的图形渲染直接采用GPU处理，在大数据调度、高速渲染、并行处理上可充分利用显卡资源，可实现各种更为复杂的渲染表现技术。\r\n4. 支持内容开发的平台架构设计，XSCOPE设计了一套全新的适用于空间信息行业的多层次交互模式，通过数据驱动+内容应用模式的可视化交互方式，XSCOPE作为平台载体的方式支持各种应用以脚本的方式运行，可以定制各种交互模式和图形展示方案，支持多视窗多任务的对象化操作，支持分析应用发布、共享、切换，具备极大的延展性和创造性。\r\n\r\n#### 应用案例\r\n##### 1.洪水分析软件平台V1.0版本\r\n2014年在全国重点地区洪水风险图编制项目中，中国水利水电科学研究院经过多方调研和平台选型，鉴于XScope®平台GIS功能完备、引擎设计灵活、适应高度定制、完全3D渲染等优势，最终采用作为洪水分析软件的基础支撑平台。历时开发一年，整合国内成熟的水利分析模型，包括复杂水利工程调度模拟的一维河网计算引擎，高分辨率二维洪水分析计算引擎、快速非结构网格生成模块，涉及到水利要素基础数据的导入、转换、建模、交互、选取、编辑、分析、显示、统计、查询、输出等整体流程技术，完成了一维、二维洪水模型和城市管网模型的前后处理集成和开发，实现了一二维耦合以及城市管网与二维模型耦合，为中小河流、防洪保护区、蓄滞洪区以及城市洪水风险分析提供技术支撑，并通过全国性的软件使用培训下发，在全国洪水风险图编制项目中进行应用。软件采取了全新的交互设计方式，大大简化了用户在以往同型软件的操作流程，通过高效的GPU渲染技术，大大提高了大范围大数据量条件下分析结果的实时绘制效率和显示效果，获得了用户的高度肯定。\r\n\r\n![upload successful](/blog/images/pasted-3.png)\r\n\r\n##### 2.VisualX智能配电网可视化服务平台\r\n该平台以三维 GIS为基础，以虚拟现实和智能交互为导向，以智能电网的可观测、可理解、可交互为目标，构建一套具备可视化服务、感知智能和决策支持服务三大特征的配电网综合可视化平台，将传统的二维单线图/系统图/厂站图扩展至三维图形，便于在第三维上进行数据可视化，支持金字塔瓦片、WMS、GML等规范，实现卫星遥感影像、高程数据、电子街道地图、路网和导航、高精度气象数据等基础地理信息的接入和可视化，与电网 GIS 平台、生产 PMS、配电自动化、大用户与用户、95598 等信息系统集成，特别是电网地理图、单线图、系统图等图形数据的集成与可视化。支持以大屏+多终端的方式交互，运行信息在终端以指令的方式推送到大屏进行呈现。\r\n\r\n\r\n![upload successful](/blog/images/pasted-4.png)', NULL, 0, '2020-05-11 10:22:00.000000', '2024-04-09 13:51:56.190518', NULL);
INSERT INTO `article` VALUES (6, 'oculusdx11', 'title: 基于DX11的OculusVR 渲染接口实现\nauthor: gaiaxis\ndate: 2020-06-01 14:25:53\ntags:\n---\n# 基于DX11的OculusVR 渲染接口实现\n\nDX11绘制其实就是不断的刷新并提交，为了支持默认绘制模式和VR绘制模式，我们设计一个接口，供系统启动时默认加载，也运行在使用过程中进行切换。\n\n```csharp\npublic interface IDrawContext : IDisposable\n{\n	void Init(Control target);\n	void BeginPass();\n	void DrawPass(Gaiaxis.Defines.Handler0 userrender);\n	void EndPass();\n}\n```\n<!--more-->\n\n在主程序中使用渲染接口：\n\n```csharp\npublic sealed partial class Root\n{\n	private IDrawContext fCurrentRenderMode;\n	private MonoralDrawContext mMonoral;\n	private StereoDrawContext mStereo;\n	\n	protected override void InitDevice(Control userControl)\n	{\n		this.fDrawContext = new DrawContext11T(this.fTargetControl);\n		this.fDrawContext.InitResource();\n\n		this.mMonoral = new MonoralDrawContext(this.fDrawContext);\n		this.mMonoral.Init(userControl);\n		this.fCurrentRenderMode = this.mMonoral;\n\n		if (VRMODE)\n		{\n			this.mStereo = new StereoDrawContext(this.fDrawContext);\n			this.mStereo.Init(userControl);\n			this.fCurrentRenderMode = this.mStereo;\n		}\n\n		Application.Idle += new EventHandler(OnApplicationIdle);\n	}\n	private void OnApplicationIdle(object sender, EventArgs e)\n	{\n		if(this.isShouldExit)\n		{\n			Application.Exit();\n			return;\n		}\n		while (NativeMethods.IsAppStillIdle)\n		{\n			if (this.m_isRenderDisabled || this.IsPause)\n			{\n				return;\n			}\n			try\n			{\n				float timeSinceStart = (float)(DateTime.Now - fStartTime).TotalSeconds;\n				this.BeginFrameRender();\n\n				this.UpdateThread();\n				this.fDrawContext.BeginFrame(this.fFrameData);\n				if (this.fCurrentRenderMode != null)\n				{\n					this.Render?.BeginDraw(this.fFrameData.ElapsedSecondTime);\n					this.fCurrentRenderMode.BeginPass();\n					this.fCurrentRenderMode.DrawPass(this.DrawFrame);\n\n					if (this.Render != null)\n					{\n						this.fDrawContext.SetBlend(EBlendMode.NonPremultiplied);\n						this.fDrawContext.SetDepthStencil(EZWEnableMode.ZRDisable);\n						this.fDrawContext.SetRasterizerCullNoneScissor();\n						this.Render.Present();\n						this.fDrawContext.SetRasterizerCullNone();\n					}\n					this.fCurrentRenderMode.EndPass();\n				}\n			}\n			catch (Exception caught)\n			{\n				Logger.Instance.RecordOperation(caught, LoggingLevel.CreateDebugFile);\n			}\n			finally\n			{\n				this.EndFrameRender();\n			}\n		}\n	}\n}\n```\n默认绘制方式如下：\n```csharp\npublic class MonoralDrawContext : IDrawContext\n{ \n	private Gaiaxis.DirectX11.DrawContext11T fDrawContext;\n	public MonoralDrawContext(Gaiaxis.DirectX11.DrawContext11T drawContext)\n	{\n		this.fDrawContext = drawContext;\n	}\n	public void Init(Control target)\n	{           \n	}\n	public void BeginPass()\n	{\n		this.fDrawContext.SetBackBufferRenderTarget();\n		this.fDrawContext.ClearBackBuffer(Color.Black);\n	}\n	public void DrawPass(Gaiaxis.Defines.Handler0 userrender)\n	{\n		userrender();\n	}\n	public void EndPass()\n	{\n		this.fDrawContext.Present(Root.Instance.WorldSettings.EnableVsync);\n	}\n}\n```\nOculus的绘制实现类如下：\n```csharp\npublic class StereoDrawContext : IDrawContext\n{\n	public class HandlerController\n	{\n	private BasicModel model;\n	private float modelscale = 0.75f;\n	private Matrix MatrixofXinvert = Matrix.Identity;\n	private OculusW.HandType handType = HandType.Left;\n\n	private SharpDX.Direct3D11.ShaderResourceView handtexture;\n	public HandlerController(BasicModel model, OculusW.HandType tp, Matrix invert)\n	{\n		this.model = model;\n		this.handType = tp;\n		this.MatrixofXinvert = invert;\n		this.handtexture = Gaiaxis.DirectX11.Resources.Textures[\"Lightning-Beam-psd42615.png\"].Object;\n	}\n\n	public void DrawModel(Gaiaxis.DirectX11.DrawContext11T dc, Posef handler, Matrix v, Matrix p)\n	{\n		SharpDX.Direct3D11.DeviceContext drawcontext = dc.ImmediateContext;\n		Matrix world = SharpDXHelpers.FromQuad(handler.Orientation);\n		world.Transpose();\n		world.TranslationVector = handler.Position.ToVector3();\n\n		//fxBasicalShader.Instance.BeginDrawNormalColored(this.fDrawContext.ImmediateContext, wvp, ne Color4(0.5f, 0.5f, 0.5f, 0.5f));\n		//this.mLeftModel.Begin(this.fDrawContext.ImmediateContext);\n		//for (int m = 0; m < this.mLeftModel.SubsetCount; m++)\n		//{\n		//    this.mLeftModel.DrawSubset(this.fDrawContext.ImmediateContext, m);\n		//}\n		//fxBasicalShader.Instance.EndDraw(this.fDrawContext.ImmediateContext);\n\n		if (this.model != null)\n		{\n			SharpDX.Vector3 cen = (this.model.Max + this.model.Min) * 0.5f;\n			var refcenter = Matrix.Translation(-cen);\n			fxModelBoxShader.Instance.BeginDrawFixedModel(drawcontext, v, p, Matrix.Identity, Vector4.Zero, Vector3.UnitZ, Color4.Black, 0.0001f, false);\n			this.model.Begin(drawcontext);\n			for (int m = 0; m < this.model.MeshesToDraw.Count; m++)\n			{\n				MeshDrawCall drawParams = this.model.MeshesToDraw[m];\n				Matrix w = drawParams.World * refcenter * this.MatrixofXinvert * world;\n				int i = drawParams.MeshPartIndex;\n				var pa = this.model.Subsets[i];\n				var material = pa.MaterialT;\n\n				fxModelBoxShader.Instance.UpdateModelMaterial(drawcontext, w, material, Color.DarkGray, 0.25f, false);\n				fxModelBoxShader.Instance.SetFixedModelShader(drawcontext, material.DiffuseTextureView);\n				this.model.DrawSubset(drawcontext, i);\n			}\n			}\n		dc.SetRasterizerCullNone();\n		fxBasicalShader.Instance.BeginDrawTextured(dc.ImmediateContext, Matrix.Scaling(0.02f, 0.02f, -1000f) * world, v * p, this.handtexture, this.handtexture, Color.Lime, EColorTextureMode.ColoredTexturedGray);\n		SharpMeshGenerator.Instance.DrawXZBottomQuad(dc);\n		fxBasicalShader.Instance.EndDraw(dc.ImmediateContext);\n		}\n	}\n	private IntPtr sessionPtr;\n	private EyeTexture[] eyeTextures = null;\n	private Texture2D mirrorTextureD3D = null;\n	private MirrorTexture mirrorTexture = null;\n	private Ab3d.OculusWrap.Result result;\n	private OvrWrap OVR;\n	private LayerEyeFov layerEyeFov;\n	private HmdDesc hmdDesc;\n\n	private readonly Vector3f UpVector = new Vector3f(0.0f, 1.0f, 0.0f);\n	private readonly Vector3f ForwardVector = new Vector3f(0.0f, 0.0f, -1.0f); // -1 because HMD looks along -Z at identity orientation\n\n	private Gaiaxis.DirectX11.DrawContext11T fDrawContext;\n\n\n	private BasicModel mLeftModel;\n	private const string fModelStringpath = @\"Data\\Model\\oculusTouchLeftModel.obj\";\n\n	private HandlerController LeftController;\n	private HandlerController RightController;\n\n	private Posef[] eyePoses = new Posef[2];\n	private InputState inputstate = new InputState();\n	private TrackingState trackingState = new  TrackingState ();\n\n\n	public StereoDrawContext(Gaiaxis.DirectX11.DrawContext11T drawContext)\n	{\n		this.fDrawContext = drawContext;\n	}\n\n	public void Dispose()\n	{\n		SharpDX.Utilities.Dispose(ref mirrorTextureD3D);\n		SharpDX.Utilities.Dispose(ref mirrorTexture);\n		SharpDX.Utilities.Dispose(ref eyeTextures[0]);\n		SharpDX.Utilities.Dispose(ref eyeTextures[1]);\n\n		// Disposing the device, before the hmd, will cause the hmd to fail when disposing.\n		// Disposing the device, after the hmd, will cause the dispose of the device to fail.\n		// It looks as if the hmd steals ownership of the device and destroys it, when it\'s shutting down.\n		// device.Dispose();\n		OVR.Destroy(sessionPtr);\n	}\n\npublic void Init(Control target)\n{\n	this.mLeftModel = SharpBasicModelGenerator.CreateNormalMappedFromObj(this.fDrawContext.Device, fModelStringpath);\n	this.LeftController = new HandlerController(this.mLeftModel, HandType.Left, Matrix.Scaling(1));\n	this.RightController = new HandlerController(this.mLeftModel, HandType.Right, Matrix.Scaling(-1, 1, 1));\n\n	Guid textureInterfaceId = new Guid(\"6f15aaf2-d208-4e89-9ab4-489535d34f9c\"); // Interface ID of the Direct3D Texture2D interface.\n\n	OVR = OvrWrap.Create();\n	// Define initialization parameters with debug flag.\n	InitParams initializationParameters = new InitParams();\n	initializationParameters.Flags = InitFlags.Debug | InitFlags.RequestVersion;\n	initializationParameters.RequestedMinorVersion = 17;\n	// Initialize the Oculus runtime.\n	string errorReason = null;\n	try\n	{\n		result = OVR.Initialize(initializationParameters);\n		if (result < Ab3d.OculusWrap.Result.Success)\n			errorReason = result.ToString();\n	}\n	catch (Exception ex)\n	{\n		errorReason = ex.Message;\n	}\n\n	if (errorReason != null)\n	{\n		MessageBox.Show(\"Failed to initialize the Oculus runtime library:\\r\\n\" + errorReason, \"Error\", MessageBoxButtons.OK, MessageBoxIcon.Error);\n	return;\n	}\n\n	// Use the head mounted display.\n	sessionPtr = IntPtr.Zero;\n	var graphicsLuid = new GraphicsLuid();\n	result = OVR.Create(ref sessionPtr, ref graphicsLuid);\n	if (result < Ab3d.OculusWrap.Result.Success)\n	{\n	MessageBox.Show(\"The HMD is not enabled: \" + result.ToString(), \"Error\", MessageBoxButtons.OK, MessageBoxIcon.Error);\n	return;\n	}\n	OVR.SetTrackingOriginType(this.sessionPtr, TrackingOrigin.FloorLevel);\n	hmdDesc = OVR.GetHmdDesc(sessionPtr);\n\n	// Create a set of layers to submit.\n	eyeTextures = new EyeTexture[2];\n	var viewport = new ViewportF(0, 0, hmdDesc.Resolution.Width, hmdDesc.Resolution.Height, 0.0f, 1.0f);\n	var des = String.Format(\"VRResolution: w:{0} h:{1}\", viewport.Width.ToString(), viewport.Height.ToString());\n	Gaiaxis.Consoles.Logger.Instance.RecordOperation(des, LoggingLevel.LogListData);\n	fDrawContext.SetScreenViewPort(viewport);\n\n	layerEyeFov = new LayerEyeFov();\n	layerEyeFov.Header.Type = LayerType.EyeFov;\n	layerEyeFov.Header.Flags = LayerFlags.None;\n\n	for (int eyeIndex = 0; eyeIndex < 2; eyeIndex++)\n	{\n	EyeType eye = (EyeType)eyeIndex;\n	var eyeTexture = new EyeTexture();\n	eyeTextures[eyeIndex] = eyeTexture;\n\n	// Retrieve size and position of the texture for the current eye.\n	eyeTexture.FieldOfView = hmdDesc.DefaultEyeFov[eyeIndex];\n	eyeTexture.TextureSize = OVR.GetFovTextureSize(sessionPtr, eye, hmdDesc.DefaultEyeFov[eyeIndex], 1.0f);\n	//eyeTexture.RenderDescription		= hmd.GetRenderDesc(eye, hmd.DefaultEyeFov[eyeIndex]);\n	eyeTexture.HmdToEyeViewOffset = eyeTexture.RenderDescription.HmdToEyePose.Position;\n	eyeTexture.ViewportSize.Position = new Vector2i(0, 0);\n	eyeTexture.ViewportSize.Size = eyeTexture.TextureSize;\n	eyeTexture.Viewport = new Viewport(0, 0, eyeTexture.TextureSize.Width, eyeTexture.TextureSize.Height, 0.0f, 1.0f);\n\n	// Define a texture at the size recommended for the eye texture.\n	eyeTexture.Texture2DDescription = new Texture2DDescription();\n	eyeTexture.Texture2DDescription.Width = eyeTexture.TextureSize.Width;\n	eyeTexture.Texture2DDescription.Height = eyeTexture.TextureSize.Height;\n	eyeTexture.Texture2DDescription.ArraySize = 1;\n	eyeTexture.Texture2DDescription.MipLevels = 1;\n	eyeTexture.Texture2DDescription.Format = Format.R8G8B8A8_UNorm_SRgb;\n	eyeTexture.Texture2DDescription.SampleDescription = new SampleDescription(1, 0);\n	eyeTexture.Texture2DDescription.Usage = ResourceUsage.Default;\n	eyeTexture.Texture2DDescription.CpuAccessFlags = CpuAccessFlags.None;\n	eyeTexture.Texture2DDescription.BindFlags = BindFlags.ShaderResource | BindFlags.RenderTarget;\n\n	// Convert the SharpDX texture description to the Oculus texture swap chain description.\n	TextureSwapChainDesc textureSwapChainDesc = SharpDXHelpers.CreateTextureSwapChainDescription(eyeTexture.Texture2DDescription);\n\n	// Create a texture swap chain, which will contain the textures to render to, for the current eye.\n	IntPtr textureSwapChainPtr;\n\n	result = OVR.CreateTextureSwapChainDX(sessionPtr, fDrawContext.Device.NativePointer, ref textureSwapChainDesc, out textureSwapChainPtr);\n	WriteErrorDetails(OVR, result, \"Failed to create swap chain.\");\n\n	eyeTexture.SwapTextureSet = new TextureSwapChain(OVR, sessionPtr, textureSwapChainPtr);\n\n	// Retrieve the number of buffers of the created swap chain.\n	int textureSwapChainBufferCount;\n	result = eyeTexture.SwapTextureSet.GetLength(out textureSwapChainBufferCount);\n	WriteErrorDetails(OVR, result, \"Failed to retrieve the number of buffers of the created swap chain.\");\n\n	// Create room for each DirectX texture in the SwapTextureSet.\n	eyeTexture.Textures = new Texture2D[textureSwapChainBufferCount];\n	eyeTexture.RenderTargetViews = new RenderTargetView[textureSwapChainBufferCount];\n\n	// Create a texture 2D and a render target view, for each unmanaged texture contained in the SwapTextureSet.\n	for (int textureIndex = 0; textureIndex < textureSwapChainBufferCount; textureIndex++)\n	{\n	// Retrieve the Direct3D texture contained in the Oculus TextureSwapChainBuffer.\n	IntPtr swapChainTextureComPtr = IntPtr.Zero;\n	result = eyeTexture.SwapTextureSet.GetBufferDX(textureIndex, textureInterfaceId, out swapChainTextureComPtr);\n	WriteErrorDetails(OVR, result, \"Failed to retrieve a texture from the created swap chain.\");\n	// Create a managed Texture2D, based on the unmanaged texture pointer.\n	eyeTexture.Textures[textureIndex] = new Texture2D(swapChainTextureComPtr);\n	// Create a render target view for the current Texture2D.\n	eyeTexture.RenderTargetViews[textureIndex] = new RenderTargetView(fDrawContext.Device, eyeTexture.Textures[textureIndex]);\n	}\n\n	// Define the depth buffer, at the size recommended for the eye texture.\n	eyeTexture.DepthBufferDescription = new Texture2DDescription();\n	eyeTexture.DepthBufferDescription.Format = Format.D32_Float;\n	eyeTexture.DepthBufferDescription.Width = eyeTexture.TextureSize.Width;\n	eyeTexture.DepthBufferDescription.Height = eyeTexture.TextureSize.Height;\n	eyeTexture.DepthBufferDescription.ArraySize = 1;\n	eyeTexture.DepthBufferDescription.MipLevels = 1;\n	eyeTexture.DepthBufferDescription.SampleDescription = new SampleDescription(1, 0);\n	eyeTexture.DepthBufferDescription.Usage = ResourceUsage.Default;\n	eyeTexture.DepthBufferDescription.BindFlags = BindFlags.DepthStencil;\n	eyeTexture.DepthBufferDescription.CpuAccessFlags = CpuAccessFlags.None;\n	eyeTexture.DepthBufferDescription.OptionFlags = ResourceOptionFlags.None;\n\n	// Create the depth buffer.\n	eyeTexture.DepthBuffer = new Texture2D(fDrawContext.Device, eyeTexture.DepthBufferDescription);\n	eyeTexture.DepthStencilView = new DepthStencilView(fDrawContext.Device, eyeTexture.DepthBuffer);\n\n	// Specify the texture to show on the HMD.\n	if (eyeIndex == 0)\n	{\n		layerEyeFov.ColorTextureLeft = eyeTexture.SwapTextureSet.TextureSwapChainPtr;\n		layerEyeFov.ViewportLeft.Position = new Vector2i(0, 0);\n		layerEyeFov.ViewportLeft.Size = eyeTexture.TextureSize;\n		layerEyeFov.FovLeft = eyeTexture.FieldOfView;\n	}\n	else\n	{\n		layerEyeFov.ColorTextureRight = eyeTexture.SwapTextureSet.TextureSwapChainPtr;\n		layerEyeFov.ViewportRight.Position = new Vector2i(0, 0);\n		layerEyeFov.ViewportRight.Size = eyeTexture.TextureSize;\n		layerEyeFov.FovRight = eyeTexture.FieldOfView;\n	}\n	}\n\n	MirrorTextureDesc mirrorTextureDescription = new MirrorTextureDesc();\n	mirrorTextureDescription.Format = TextureFormat.R8G8B8A8_UNorm_SRgb;\n	mirrorTextureDescription.Width = target.Width;\n	mirrorTextureDescription.Height = target.Height;\n	mirrorTextureDescription.MiscFlags = TextureMiscFlags.None;\n\n	// Create the texture used to display the rendered result on the computer monitor.\n	IntPtr mirrorTexturePtr;\n	result = OVR.CreateMirrorTextureDX(sessionPtr, fDrawContext.Device.NativePointer, ref mirrorTextureDescription, out mirrorTexturePtr);\n	WriteErrorDetails(OVR, result, \"Failed to create mirror texture.\");\n\n	mirrorTexture = new MirrorTexture(OVR, sessionPtr, mirrorTexturePtr);\n\n\n	// Retrieve the Direct3D texture contained in the Oculus MirrorTexture.\n	IntPtr mirrorTextureComPtr = IntPtr.Zero;\n	result = mirrorTexture.GetBufferDX(textureInterfaceId, out mirrorTextureComPtr);\n	WriteErrorDetails(OVR, result, \"Failed to retrieve the texture from the created mirror texture buffer.\");\n\n	// Create a managed Texture2D, based on the unmanaged texture pointer.\n	mirrorTextureD3D = new Texture2D(mirrorTextureComPtr);\n}\n\npublic void BeginPass()\n{\n	this.fDrawContext.ClearBackBuffer(Color.Black);\n}\n\npublic void DrawPass(Gaiaxis.Defines.Handler0 userrender)\n{\n	try\n	{\n		double displayMidpoint = OVR.GetPredictedDisplayTime(sessionPtr, 0);\n		this.trackingState = OVR.GetTrackingState(sessionPtr, displayMidpoint, true);\n\n		var leppost = trackingState.HandPoses[(int)OculusW.HandType.Left].ThePose;\n		var rigpose = trackingState.HandPoses[(int)OculusW.HandType.Right].ThePose;\n\n		var ConnectedControllerTypes = OVR.GetConnectedControllerTypes(this.sessionPtr);\n		var result = OVR.GetInputState(sessionPtr, ControllerType.Touch, ref this.inputstate);\n		if (result == OculusW.Result.Success)\n		{\n		if (inputstate.Buttons != 0)\n		{\n		}\n		if ((inputstate.Buttons & (uint)OculusW.Button.A) == (uint)OculusW.Button.A)\n		{\n		OVR.RecenterTrackingOrigin(this.sessionPtr);\n		}\n		if ((inputstate.Buttons & (uint)OculusW.Button.B) == (uint)OculusW.Button.B)\n		{\n		OVR.RecenterTrackingOrigin(this.sessionPtr);\n		}\n\n		if ((inputstate.Buttons & (uint)OculusW.Button.X) == (uint)OculusW.Button.X)\n		{\n		OVR.RecenterTrackingOrigin(this.sessionPtr);\n		}\n		if ((inputstate.Buttons & (uint)OculusW.Button.Y) == (uint)OculusW.Button.Y)\n		{\n		OVR.RecenterTrackingOrigin(this.sessionPtr);\n		}\n		if ((inputstate.Buttons & (uint)OculusW.Button.Enter) == (uint)OculusW.Button.Enter)\n		{\n		}\n\n		if (Root.Instance.CurrentGame is IEnableVRController)\n		{\n		IEnableVRController cc = (Root.Instance.CurrentGame as IEnableVRController);\n		var left = inputstate.ThumbstickRaw[(int)OculusW.HandType.Left];\n		var right = inputstate.ThumbstickRaw[(int)OculusW.HandType.Right];\n		cc.DoLeftMoveTrggie(left.X, left.Y);\n		cc.DoRightMoveTrggie(right.X, right.Y);\n\n		var leftht = inputstate.HandTrigger[(int)OculusW.HandType.Left];\n		var rightht = inputstate.HandTrigger[(int)OculusW.HandType.Right];\n\n		if (leftht > 0.5f)\n		{\n		cc.DoZoomTriggle(-1, 1.05f);\n		}\n		if (rightht > 0.5f)\n		{\n		cc.DoZoomTriggle(1, 1.05f);\n		}\n		if (inputstate.IndexTrigger[(int)OculusW.HandType.Left] > 0.5f)\n		{\n\n		}\n		if (inputstate.IndexTrigger[(int)OculusW.HandType.Right] > 0.5f)\n		{\n		cc.DoShoot();\n		}\n		}\n		}\n\n\n		Vector3f[] hmdToEyeViewOffsets = { eyeTextures[0].HmdToEyeViewOffset, eyeTextures[1].HmdToEyeViewOffset };\n		// Calculate the position and orientation of each eye.\n		OVR.CalcEyePoses(trackingState.HeadPose.ThePose, hmdToEyeViewOffsets, ref eyePoses);\n\n		for (int eyeIndex = 0; eyeIndex < 2; eyeIndex++)\n		{\n			EyeType eye = (EyeType)eyeIndex;\n			EyeTexture eyeTexture = eyeTextures[eyeIndex];\n\n			if (eyeIndex == 0)\n			layerEyeFov.RenderPoseLeft = eyePoses[0];\n			else\n			layerEyeFov.RenderPoseRight = eyePoses[1];\n\n			// Update the render description at each frame, as the HmdToEyeOffset can change at runtime.\n			eyeTexture.RenderDescription = OVR.GetRenderDesc(sessionPtr, eye, hmdDesc.DefaultEyeFov[eyeIndex]);\n\n			// Retrieve the index of the active texture\n			int textureIndex;\n			result = eyeTexture.SwapTextureSet.GetCurrentIndex(out textureIndex);\n			WriteErrorDetails(OVR, result, \"Failed to retrieve texture swap chain current index.\");\n\n			this.fDrawContext.SetOffscreenRenderTargets(eyeTexture.RenderTargetViews[textureIndex], eyeTexture.DepthStencilView, eyeTexture.Viewport.Width, eyeTexture.Viewport.Height);\n			this.fDrawContext.ClearBackBuffer(Color.Black);\n			this.fDrawContext.SetBlend(EBlendMode.Add);\n			this.fDrawContext.SetDepthStencil(EZWEnableMode.ZWDisable);\n			//this.fDrawContext.ImmediateContext.OutputMerger.SetRenderTargets();\n			//this.fDrawContext.DisplayViewPort = eyeTexture.Viewport;\n			//this.fDrawContext.ImmediateContext.ClearRenderTargetView(eyeTexture.RenderTargetViews[textureIndex], Color.Black);\n			//this.fDrawContext.ImmediateContext.ClearDepthStencilView(eyeTexture.DepthStencilView, DepthStencilClearFlags.Depth | DepthStencilClearFlags.Stencil, 1.0f, 0);\n\n			Matrix projectionMatrix = OVR.Matrix4f_Projection(eyeTexture.FieldOfView, 1f, 10000000.0f, ProjectionModifier.LeftHanded).ToMatrix();\n			projectionMatrix.Transpose();\n			this.fDrawContext.ProjectT = projectionMatrix;\n\n			Quaternion rotationQuaternion = SharpDXHelpers.ToQuaternion(eyePoses[eyeIndex].Orientation);\n			Matrix rotationMatrix = Matrix.RotationQuaternion(rotationQuaternion);\n\n			this.fDrawContext.HeadletsRotation = rotationMatrix.ToMatrix4d();\n			this.fDrawContext.EysposesOffset = eyePoses[eyeIndex].Position.ToVector3D();\n\n			userrender();\n			this.fDrawContext.DisplayViewPort = eyeTexture.Viewport;\n\n			var viewmatrix = this.CaculaterFromPoses(eyePoses[eyeIndex]);\n\n			Matrix projectionMatrix2 = OVR.Matrix4f_Projection(eyeTexture.FieldOfView, 0.00f, 1000000.0f, ProjectionModifier.None).ToMatrix();\n			projectionMatrix2.Transpose();\n\n			this.fDrawContext.SetBlend(EBlendMode.Alpha);\n			this.fDrawContext.SetDepthStencil(EZWEnableMode.ZWDisable);\n			this.fDrawContext.SetRasterizerCullNone();\n			if ((ConnectedControllerTypes & ControllerType.LTouch) == ControllerType.LTouch)\n			{\n				this.LeftController.DrawModel(this.fDrawContext, leppost, viewmatrix, projectionMatrix2);\n			}\n			if ((ConnectedControllerTypes & ControllerType.RTouch) == ControllerType.RTouch)\n			{\n				this.RightController.DrawModel(this.fDrawContext, rigpose, viewmatrix, projectionMatrix2);\n			}\n			// Commits any pending changes to the TextureSwapChain, and advances its current index\n			result = eyeTexture.SwapTextureSet.Commit();\n			WriteErrorDetails(OVR, result, \"Failed to commit the swap chain texture.\");\n		}\n\n		result = OVR.SubmitFrame(sessionPtr, 0L, IntPtr.Zero, ref layerEyeFov);\n		WriteErrorDetails(OVR, result, \"Failed to submit the frame of the current layers.\"); \n	}\n	catch\n	{ }\n	finally\n	{\n	}\n}\n\n	public void EndPass()\n	{\n		this.fDrawContext.Present(false);\n	}\n\n	private Matrix CaculaterFromPoses(Posef posef)\n	{\n		Vector3 up = posef.Orientation.Rotate(UpVector).ToVector3();\n		Vector3 forward = posef.Orientation.Rotate(ForwardVector).ToVector3();\n		Vector3 viewPos = posef.Position.ToVector3();\n		var m1 = Matrix.LookAtRH(viewPos, viewPos + forward, up);\n		return m1;\n	}\n	/// <summary>\n	/// Write out any error details received from the Oculus SDK, into the debug output window.\n	/// \n	/// Please note that writing text to the debug output window is a slow operation and will affect performance,\n	/// if too many messages are written in a short timespan.\n	/// </summary>\n	/// <param name=\"OVR\">OvrWrap object for which the error occurred.</param>\n	/// <param name=\"result\">Error code to write in the debug text.</param>\n	/// <param name=\"message\">Error message to include in the debug text.</param>\n	private void WriteErrorDetails(OvrWrap OVR, OculusW.Result result, string message)\n	{\n		if (result >= OculusW.Result.Success)\n		return;\n\n		// Retrieve the error message from the last occurring error.\n		ErrorInfo errorInformation = OVR.GetLastErrorInfo();\n\n		string formattedMessage = string.Format(\"{0}. \\nMessage: {1} (Error code={2})\", message, errorInformation.ErrorString, errorInformation.Result);\n		Trace.WriteLine(formattedMessage);\n		MessageBox.Show(formattedMessage, message);\n\n		throw new Exception(formattedMessage);\n	}\n}\n```', NULL, 0, '2020-06-01 14:25:53.000000', '2024-04-09 13:51:56.190518', NULL);
INSERT INTO `article` VALUES (7, 'processcmd', 'title: 启动外挂执行程序方法\r\nauthor: gaiaxis\r\ntags: []\r\ncategories: []\r\ndate: 2020-06-03 09:30:00\r\n---\r\n# 启动外挂执行程序方法\r\n\r\n在有些系统开发过程中需要启动第三方独立的软件进行计算或者处理某个事件，可以在process中启动该程序，一般通过两种方式：\r\n1.	显示控制台窗口\r\n2.	后台静默运行\r\n\r\n步骤如下：\r\n1.	定义执行程序路径\r\n\r\n```csharp\r\nprotected static string maiexecutor = Application.StartupPath + \"\\\\runtimes\\\\thirdparty.exe\" ;\r\n```\r\n<!--more-->\r\n2.	点击按钮执行启动\r\n配置文件在WorkPath文件夹中\r\n \r\n```csharp\r\n    if (ImGui.ImageButton(XShareData.mModelStartID, XShareData.MiniToolbarIconSize))\r\n	{\r\n		this.DoSerialCaculator();\r\n	}\r\n    protected void DoSerialCaculator()\r\n	{\r\n		Root.Instance.RunInvoke(() =>\r\n		{\r\n			XShareData.Instance.RunCommand(maiexecutor, WorkPath, this.Process_Exited);\r\n		});\r\n	}\r\n```\r\n#  \r\n\r\n\r\n        /// <summary>\r\n        /// 后台运行模式\r\n        /// </summary>\r\n        /// <param name=\"execute\"></param>\r\n        /// <param name=\"targetdirection\"> \"./runtimes/input\"</param>\r\n        /// <param name=\"args\"></param>\r\n        public void RunCommand(string execute, string targetdirection, System.EventHandler exit, string args = \"\")\r\n        {\r\n            System.Windows.Forms.Control.CheckForIllegalCrossThreadCalls = false;\r\n            Process process = new Process();\r\n            process.StartInfo.FileName = execute;\r\n            process.StartInfo.WorkingDirectory = targetdirection;\r\n            process.StartInfo.UseShellExecute = false; //false 直接从可执行文件创建进程\r\n\r\n            process.StartInfo.RedirectStandardInput = true;\r\n            process.StartInfo.RedirectStandardOutput = true;\r\n            process.StartInfo.RedirectStandardError = true;\r\n            process.StartInfo.CreateNoWindow = true;\r\n\r\n            process.OutputDataReceived += process_OutputDataReceived;\r\n            process.ErrorDataReceived += Process_ErrorDataReceived;\r\n            process.Exited += exit;\r\n\r\n            process.Start();\r\n            process.EnableRaisingEvents = true;\r\n            process.BeginOutputReadLine();\r\n            process.BeginErrorReadLine();\r\n        }\r\n        /// <summary>\r\n        /// CMD窗口模式\r\n        /// </summary>\r\n        /// <param name=\"execute\"></param>\r\n        /// <param name=\"targetdirection\"></param>\r\n        /// <param name=\"exit\"></param>\r\n        /// <param name=\"args\"></param>\r\n        public void RunWindowCommand(string execute, string targetdirection, System.EventHandler exit, string args = \"\")\r\n        {\r\n            Process process = new Process();\r\n            process.StartInfo.FileName = execute;\r\n            process.StartInfo.WorkingDirectory = targetdirection;// \"./runtimes/input\"\r\n            process.StartInfo.UseShellExecute = true; //false 直接从可执行文件创建进程\r\n            process.StartInfo.Arguments = args;\r\n            process.OutputDataReceived += process_OutputDataReceived;\r\n            process.ErrorDataReceived += Process_ErrorDataReceived;\r\n            process.Exited += exit;\r\n            process.Start();\r\n        }\r\n\r\n        protected void Process_ErrorDataReceived(object sender, DataReceivedEventArgs e)\r\n        {\r\n            System.Console.WriteLine(e.Data);\r\n            Gaiaxis.Consoles.GraphicsManager.Instance.ShowFlareText(e.Data, false);\r\n        }\r\n        protected void process_OutputDataReceived(object sender, DataReceivedEventArgs e)\r\n        {\r\n            System.Console.WriteLine(e.Data);\r\n            Gaiaxis.Consoles.GraphicsManager.Instance.ShowFlareText(e.Data, false);\r\n        }', NULL, 0, '2020-06-03 09:30:00.000000', '2024-04-09 13:51:56.190518', NULL);
INSERT INTO `article` VALUES (8, 'usersetplot', 'title: 使用Plot图表插件和自定义设计图表\r\nauthor: gaiaxis\r\ntags:\r\n  - PLOT\r\ncategories:\r\n  - PLOT\r\ndate: 2020-05-27 12:18:00\r\n---\r\n#### 自定义PLOT图表的开发流程\r\n\r\n+	在window类里面引用  \r\n```html\r\nusing Gaiaxis.Components.Oxyplots.PlotModels\r\n```\r\n2.	初始化注册图表库的应用 \r\n```html\r\nthis. RegeditorPlotsample();\r\n```\r\n\r\n![upload successful](/blog/images/pasted-5.png)\r\n<!-- more -->\r\n \r\n3.	启动系统，在应用模式下面点击图表库，然后点击应用选项，点击图层显示\r\n\r\n![upload successful](/blog/images/pasted-6.png)\r\n \r\n4.	可以看到自定义的测试样例效果，目前底层仅支持柱状图横向纵向，和曲线图、饼图。\r\n\r\n![upload successful](/blog/images/pasted-7.png)\r\n\r\n![upload successful](/blog/images/pasted-8.png)\r\n  \r\n副标题是方法名称。\r\n \r\n\r\n![upload successful](/blog/images/pasted-9.png)\r\n\r\n<!-- more -->\r\n如何自己扩充新的图表样式，参照\r\n\r\n\r\n![upload successful](/blog/images/pasted-10.png)\r\n \r\n \r\n如何统一改变色系\r\n在每个plotmodel创建之后，自己重新设置下defaultcolor,如果里面的对象没有人为指定颜色，会依次从这里取，这个色系可参照网上的配色方案。\r\n\r\n\r\n![upload successful](/blog/images/pasted-11.png)\r\n \r\n \r\n ```html\r\nusing ExampleLibrary;\r\nusing Gaiaxis.Defines;\r\nusing Gaiaxis.MathUtilities;\r\nusing OxyPlot;\r\nusing OxyPlot.Series;\r\nusing System;\r\nusing System.Collections.Generic;\r\nusing System.Linq;\r\nusing System.Reflection;\r\nnamespace Gaiaxis.Components.Oxyplots.PlotModels\r\n{\r\n    /// <summary>\r\n    /// 本地自定义标准图形的写法\r\n    /// </summary>\r\n    public static class PlotPiePlugin\r\n    {\r\n        /// <summary>\r\n        /// 环形图,区别于之前的\r\n        /// </summary>\r\n        /// <param name=\"name\">表名</param>\r\n        /// <param name=\"data\">数据类型</param>\r\n        /// <param name=\"colorStyle\">样式</param>\r\n        /// <param name=\"InnerDiameter\">内圈半径</param>\r\n        /// <param name=\"Diameter\">外圈半径</param>\r\n        /// <param name=\"ExplodedDistance\">往外延申距离</param>\r\n        /// <param name=\"isshowmarklabel\">是否显示标记百分比</param>\r\n        /// <param name=\"isshowNum\">是否显示中心数值</param>\r\n        /// <param name=\"width\">表宽</param>\r\n        /// <param name=\"height\">表高</param>\r\n        /// <returns></returns>\r\n        public static void CreatePieCircle(this OxySeriesModel model, DataType2T<int> data, float InnerDiameter = 0, float Diameter = 0.7f, float ExplodedDistance = 0.01f)\r\n        {\r\n            double totalcount = 0;\r\n            wPieSlice[] items = OxyPlotHelper.DataTypeToPieSlice(data);\r\n            if (items == null)\r\n            {\r\n                return;\r\n            }\r\n            var pieSeries = new PieSeries()\r\n            {\r\n                OutsideLabelFormat = \"{2:0.0}%\",\r\n                TickLabelDistance = 2,\r\n                InnerDiameter = InnerDiameter,\r\n                ExplodedDistance = ExplodedDistance,\r\n                Stroke = OxyColors.Transparent,\r\n                StrokeThickness = 0,\r\n                Diameter = Diameter,\r\n                AngleSpan = 360.0,\r\n                StartAngle = 0\r\n            };\r\n            foreach (var item in items)\r\n            {\r\n                pieSeries.Slices = items;\r\n                totalcount += item.Value;\r\n            }\r\n            model.IsLegendVisible = false;\r\n            model.Series.Clear();\r\n            model.Annotations.Clear();\r\n            model.Series.Add(pieSeries);\r\n\r\n            //if (isshownum && isHasData)\r\n            //{\r\n            //    //渲染饼状图中心数值渲染\r\n            //    this.Annotations.Add(new DelegateAnnotation(rc =>\r\n            //    {\r\n\r\n            //        double X = (int)(w / 2 + 5);\r\n            //        double y = (int)(h / 2);\r\n            //        rc.DrawText(new ScreenPoint(X, y += D), CenterDescription, this.TextColor, Font, FontSize, FontWeight, 0, HorizontalAlignment.Center, VerticalAlignment.Middle);\r\n            //    }));\r\n            //}\r\n            float D = 24;\r\n            //饼状图的 图例\r\n            model.Annotations.Add(new DelegateAnnotation(rc =>\r\n            {\r\n                var TLW = D;\r\n                var TLH = D * 2;\r\n                int index = 0;\r\n                foreach (var item in items)\r\n                {\r\n                    if (index < 6)\r\n                    {\r\n                        rc.DrawRectangle(new OxyRect(TLW, TLH, 10, 10), item.Fill, item.Fill);\r\n                        rc.DrawText(new ScreenPoint(TLW + 15, TLH), item.DesCription + \" \" + item.Value, OxyColors.White, model.Font, model.FontSize / 2, model.FontWeight / 2, 0, model.TitleHPosition, VerticalAlignment.Top);\r\n                    }\r\n                    else\r\n                    {\r\n                        if (index == 6)\r\n                        {\r\n                            TLW = 2000 - D;\r\n                            TLH = D * 2;\r\n                        }\r\n                        rc.DrawRectangle(new OxyRect(TLW, TLH, 10, 10), item.Fill, item.Fill);\r\n                        rc.DrawText(new ScreenPoint(TLW - 10, TLH), item.DesCription + \" \" + item.Value, OxyColors.White, model.Font, model.FontSize / 2, model.FontWeight / 2, 0, HorizontalAlignment.Right, VerticalAlignment.Top);\r\n                    }\r\n                    TLH += D;\r\n                    index++;\r\n                }\r\n            }));\r\n        }\r\n\r\n\r\n        public static OxySeriesModel CreatePieCircle(string name, string subname, IDataUpdateEvent owner, Func<DataType2T<int>> Getdata, float InnerDiameter = 0.25f, float Diameter = 0.7f, float ExplodedDistance = 0.01f)\r\n        {\r\n            var model = new OxySeriesModel(name, subname);\r\n            model.InitAxis();\r\n            model.CreatePieCircle(Getdata(), InnerDiameter, Diameter, ExplodedDistance);\r\n            if (owner != null)\r\n                owner.DataUpdateEvent += () =>\r\n                {\r\n                    model.CreatePieCircle(Getdata());\r\n                    (model as IPlotModel).Update(true);\r\n                };\r\n            return model;\r\n        }\r\n    }\r\n\r\n    [Examples(\"AGaiaxisUserSeries\"), Tags(\"Series\")]\r\n    public static class GaiaxisUserSeriesExamples\r\n    {\r\n        [Example(\"横向单组[直方图]\")]\r\n        [DocumentationExample(\"Series/AGaiaxisUserSeries\")]\r\n        public static PlotModel CreateBarSeries()\r\n        {\r\n            return OxyPlotHelper.CreateHorizonBarSeries1(\"横向单组直方图\", \"CreateHorizonBarSeries1\", null, DataTypeSample.Sample0);\r\n        }\r\n        [Example(\"横向单组[直方图]简介模式\")]\r\n        public static PlotModel CreateSimpleBarSeries()\r\n        {\r\n            return OxyPlotHelper.CreateHorizonBarSeriesSample1(\"横向单组直方图\", \"CreateHorizonBarSeriesSample1\", null, DataTypeSample.Sample0);\r\n        }\r\n\r\n        [Example(\"横向组合[直方图]\")]\r\n        public static PlotModel CreateTwoBarSeries()\r\n        {\r\n            return OxyPlotHelper.CreateHorizonGroupBarSeries(\"直方图\", \"CreateHorizonGroupBarSeries\", null, DataTypeSample.Sample6T);\r\n        }\r\n\r\n        [Example(\"横向组合[直方图]叠加\")]\r\n        public static PlotModel CreateTwoBarDateTimeSeries()\r\n        {\r\n            return OxyPlotHelper.CreateHorizonGroupBarSeriesStake(\"直方图\", \"CreateHorizonGroupBarSeriesStake\", null, DataTypeSample.Sample6T);\r\n        }\r\n        [Example(\"纵向单组直方图\")]\r\n        public static PlotModel CreateVerticalBarSeries()\r\n        {\r\n            return OxyPlotHelper.CreateVerticalBarSeries1(\"纵向单组直方图\", \"CreateVerticalBarSeries1\", null, DataTypeSample.Sample0);\r\n        }\r\n\r\n        [Example(\"纵向单组直方图简洁模式\")]\r\n        public static PlotModel CreateSimpleVerticalBarSeries()\r\n        {\r\n            return OxyPlotHelper.CreateVerticalBarSeriesSample1(\"纵向单组直方图\", \"CreateVerticalBarSeriesSample1\", null, DataTypeSample.Sample0);\r\n        }\r\n        [Example(\"纵向组合直方图\")]\r\n        public static PlotModel CreateTwoBarVerticalSeries()\r\n        {\r\n            return OxyPlotHelper.CreateVerticalGroupBarSeries(\"直方图\", \"CreateVerticalGroupBarSeries\", null, DataTypeSample.Sample6T);\r\n        }\r\n\r\n        [Example(\"时间-数值曲线1\")]\r\n        public static PlotModel CreateDateTimeVerticalSeries1()\r\n        {\r\n            return OxyPlotHelper.CreateCurvePathSeries(\"时间-数值曲线\", \"CreateCurvePathSeries\", null, PathSeriesMode.Area, DataTypeSample.Sample6TDate);\r\n        }\r\n        [Example(\"时间-数值曲线2\")]\r\n        public static PlotModel CreateDateTimeVerticalSeries2()\r\n        {\r\n            return OxyPlotHelper.CreateCurvePathSeries(\"时间-数值曲线\", \"CreateCurvePathSeries\", null, PathSeriesMode.PathLine, DataTypeSample.Sample6TDate);\r\n        }\r\n        [Example(\"时间-数值曲线3\")]\r\n        public static PlotModel CreateDateTimeVerticalSeries3()\r\n        {\r\n            return OxyPlotHelper.CreateCurvePathSeries(\"时间-数值曲线\", \"CreateCurvePathSeries\", null, PathSeriesMode.Stair, DataTypeSample.Sample6TDate);\r\n        }\r\n        [Example(\"时间-数值曲线4\")]\r\n        public static PlotModel CreateDateTimeVerticalSeries4()\r\n        {\r\n            return OxyPlotHelper.CreateCurvePathSeries(\"时间-数值曲线\", \"CreateCurvePathSeries\", null, PathSeriesMode.Stem, DataTypeSample.Sample6TDate);\r\n        }\r\n\r\n        [Example(\"饼图\")]\r\n        public static PlotModel CreatePieCircle2()\r\n        {\r\n            return PlotPiePlugin.CreatePieCircle(\"饼图\", \"CreatePieCircle\", null, DataTypeSample.Sample0);\r\n        }\r\n\r\n        [Example(\"散点图\")]\r\n        public static PlotModel CreateBubble()\r\n        {\r\n            return OxyPlotHelper.CreateBubble(\"散点图\", \"CreateBubble\", null, DataTypeSample.Sample0);\r\n        }\r\n    }\r\n    public class DataTypeSample\r\n    {\r\n\r\n        public static void Load(TypeInfo type, ref List<ExampleInfo> list)\r\n        {\r\n            var examplesAttribute = type.GetCustomAttributes<ExamplesAttribute>().FirstOrDefault();\r\n            if (examplesAttribute == null)\r\n            {\r\n                return;\r\n            }\r\n            var examplesTags = type.GetCustomAttributes<TagsAttribute>().FirstOrDefault() ?? new TagsAttribute();\r\n\r\n            var types = new List<Type>();\r\n            var baseType = type;\r\n            while (baseType != null)\r\n            {\r\n                types.Add(baseType.AsType());\r\n                baseType = baseType.BaseType != null ? baseType.BaseType.GetTypeInfo() : null;\r\n            }\r\n\r\n            foreach (var t in types)\r\n            {\r\n                var methods = t.GetRuntimeMethods();\r\n\r\n                foreach (var method in methods)\r\n                {\r\n                    try\r\n                    {\r\n                        var exampleAttribute = method.GetCustomAttributes<ExampleAttribute>().FirstOrDefault();\r\n                        if (exampleAttribute != null)\r\n                        {\r\n                            var exampleTags = method.GetCustomAttributes<TagsAttribute>().FirstOrDefault() ?? new TagsAttribute();\r\n                            var tags = new List<string>(examplesTags.Tags);\r\n                            tags.AddRange(exampleTags.Tags);\r\n                            list.Add(\r\n                                new ExampleInfo(\r\n                                    examplesAttribute.Category,\r\n                                    exampleAttribute.Title,\r\n                                    tags.ToArray(),\r\n                                    method));\r\n                        }\r\n                    }\r\n                    catch (Exception)\r\n                    {\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        public static DataType2T<int> Sample0()\r\n        {\r\n            DataType2T<int> data = new DataType2T<int>();\r\n            data.name = \"Name\";\r\n            data.subname = \"Subname\";\r\n            for (int i = 0; i < 20; i++)\r\n            {\r\n                data.Content.Add(\"item\" + i.ToString(), SeMath.random.Next(60));\r\n            }\r\n            return data;\r\n        }\r\n        public static DataType2T<double> Sample2TD()\r\n        {\r\n            DataType2T<double> data = new DataType2T<double>();\r\n            data.name = \"Name\";\r\n            data.subname = \"Subname\";\r\n            for (int i = 0; i < 20; i++)\r\n            {\r\n                data.Content.Add(\"item\" + i.ToString(), SeMath.random.NextDouble());\r\n            }\r\n            return data;\r\n        }\r\n\r\n        public static DataType7T<int> Sample7T()\r\n        {\r\n            DataType7T<int> data = new DataType7T<int>();\r\n            for (int i = 0; i < 20; i++)\r\n            {\r\n                data.Content.Add(DateTime.Now.AddHours(i), SeMath.random.Next(60));\r\n            }\r\n            return data;\r\n        }\r\n        public static DataType7T<float> Sample7TF()\r\n        {\r\n            DataType7T<float> data = new DataType7T<float>();\r\n            for (int i = 0; i < 20; i++)\r\n            {\r\n                data.Content.Add(DateTime.Now.AddHours(i), (float)(SeMath.random.NextDouble()));\r\n            }\r\n            return data;\r\n        }\r\n        public static DataType8T<float> Sample8TF()\r\n        {\r\n            DataType8T<float> data = new DataType8T<float>();\r\n\r\n            for (int i = 0; i < 4; i++)\r\n            {\r\n                Dictionary<DateTime, float> node = new Dictionary<DateTime, float>();\r\n                for (int m = 0; m < 8; m++)\r\n                {\r\n                    node.Add(DateTime.Now.AddHours(m), (float)(SeMath.random.NextDouble()));\r\n                }\r\n                data.Content.Add(\"item\" + i.ToString(), node);\r\n            }\r\n            return data;\r\n        }\r\n        public static DataType8T<int> Sample8T()\r\n        {\r\n            DataType8T<int> data = new DataType8T<int>();\r\n\r\n            for (int i = 0; i < 4; i++)\r\n            {\r\n                Dictionary<DateTime, int> node = new Dictionary<DateTime, int>();\r\n                for (int m = 0; m < 8; m++)\r\n                {\r\n                    node.Add(DateTime.Now.AddHours(m), (SeMath.random.Next(60)));\r\n                }\r\n                data.Content.Add(\"item\" + i.ToString(), node);\r\n            }\r\n            return data;\r\n        }\r\n\r\n        public static DataType6TDate Sample6TDate()\r\n        {\r\n            DataType6TDate data = new DataType6TDate();\r\n            for (int i = 0; i < 3; i++)\r\n            {\r\n                Dictionary<DateTime, double> node = new Dictionary<DateTime, double>();\r\n                for (int m = 0; m < 12; m++)\r\n                {\r\n                    node.Add(DateTime.Now.AddHours(m), (SeMath.random.Next(24)));\r\n                }\r\n                data.Content_timeslot.Add(\"item_\" + i.ToString(), node);\r\n            }\r\n            return data;\r\n        }\r\n        public static DataType6T Sample6T()\r\n        {\r\n            DataType6T data = new DataType6T();\r\n            for (int i = 0; i < 3; i++)\r\n            {\r\n                Dictionary<string, int> node = new Dictionary<string, int>();\r\n                for (int m = 0; m < 12; m++)\r\n                {\r\n                    node.Add(\"Subitem\" + m.ToString(), (SeMath.random.Next(60)));\r\n                }\r\n                data.Content_timeslot.Add(\"item\" + i.ToString(), node);\r\n            }\r\n            return data;\r\n        }\r\n        public static DataType9T Sample9T()\r\n        {\r\n            DataType9T data = new DataType9T();\r\n            for (int i = 0; i < 3; i++)\r\n            {\r\n                Dictionary<string, double> node = new Dictionary<string, double>();\r\n                for (int m = 0; m < 12; m++)\r\n                {\r\n                    node.Add(\"Subitem\" + m.ToString(), SeMath.random.NextDouble());\r\n                }\r\n                data.Content.Add(\"item\" + i.ToString(), node);\r\n            }\r\n            return data;\r\n        }\r\n    }\r\n}\r\n```', NULL, 0, '2020-05-27 12:18:00.000000', '2024-04-09 13:51:56.190518', NULL);
INSERT INTO `article` VALUES (9, 'vectortool', 'title: 基于矢量数据的拓展功能开发流程\r\nauthor: gaiaxis\r\ntags:\r\n  - Tool\r\ncategories:\r\n  - Tool\r\ndate: 2020-05-27 20:36:00\r\n---\r\n# 基于矢量数据的拓展功能开发流程\r\n通过拓展工具箱可以在项目中自定义开发基于点、线、面的矢量对象的处理工具，操作方式是首先导入矢量数据，在对象的右键菜单中激活拓展功能，找到对应的工具项进行操作。\r\n    面图层：VSpatialPolygonLayer\r\n    线图层：VSpatialPathLayer\r\n    点图层：VSpatialPointLayer\r\n\r\n根据工具的复杂程度，UI上有所不同。一般分两种，通用和自定义。\r\n<!--more-->\r\n\r\n## 通用型工具开发流程：\r\n1.新建一个类继承自 mTooler<T> T 代表待处理的类，该工具是针对该类对象的操作，可以是具体的类，也可以是接口，在拓展工具中，会自动匹配，如果某个类继承自该接口，也认为该类可以通过这个工具进行处理。\r\n这种方式设计上比较方便灵活。\r\n2.重写DrawInner,这里写入UI相关的代码。\r\n```csharp\r\nprotected override void DrawInner()\r\n```\r\n3.重写Process,完成点击[运行]按钮后执行的代码，这里传入的对象和this.fTarget是同一对象，使用中用哪个都行。如果有些工具不适合用运行的名称，可以在该类的构造函数中，指定按钮的名称。如\r\n```csharp\r\nthis.mBntRunName = \"数据处理\";\r\n```\r\n```csharp\r\npublic override void Process(VSpatialPointLayer line)\r\n```\r\n  \r\n![upload successful](/images/pasted-14.png)\r\n \r\n## 自定义工具开发流程：\r\n最直观的理解是没有运行按钮，自定义UI，区别于通用型开发流程，无需理会Process,除非自己UI中执行了Process。UI在DrawContent中重写。\r\n```csharp\r\npublic override void DrawContent()\r\n{\r\n    ImGui.BulletText(this.Title);\r\n    ImGui.Separator();\r\n    。。。。。\r\n}\r\n```\r\n\r\n![upload successful](/images/pasted-15.png)\r\n### 示例代码1：点图层转换为粒子元素对象\r\n```csharp\r\n    public class tMultiPointWidgetToSprite : mTooler<VSpatialPointLayer>\r\n    {\r\n        public override string Title { get { return \"[转换] 为粒子元素缩放对象\"; } }\r\n        private EModelStyle mmode = EModelStyle.XY2D;\r\n\r\n        protected override void DrawInner()\r\n        {\r\n            ImGuiHelper.Combox<EModelStyle>(\"元素类型\", ref this.mmode);\r\n        }\r\n        public override void Process(VSpatialPointLayer line)\r\n        {\r\n            XMultiPointSquareInstanceRenderDescription<PointAttribute> des = new XMultiPointSquareInstanceRenderDescription<PointAttribute>();\r\n            des.Name = line.Name + \"_Instance\";\r\n            des.ModelStyle = this.mmode;\r\n            line.CreatePointArrayDes(des);\r\n        }\r\n}\r\n```\r\n### 示例代码2：面数据转换为建筑数据\r\n```csharp\r\npublic class tMultiPolygonToSectionModelSet : mTooler<VSpatialPolygonLayer>\r\n    {\r\n        public override string Title { get { return \"[转换] 为立体Section模型对象\"; } }\r\n\r\n        public override void Process(VSpatialPolygonLayer polygon)\r\n        {\r\n            XMultiMeshSectionTileRenderDescription deset = new XMultiMeshSectionTileRenderDescription();\r\n            deset.Name = this.Name;\r\n            deset.Descrio = polygon.Description;\r\n            deset.NormalColor = polygon.DES.NormalColor;\r\n            deset.Mcenterlat = polygon.EnvelopeInner.Centre.Y;\r\n            deset.Mcenterlon = polygon.EnvelopeInner.Centre.X;\r\n            List<PolygonG> templist = new List<PolygonG>();\r\n            int totalcount = 0;\r\n            foreach (var item in polygon.Childrens.Values)\r\n            {\r\n                if (!item.IsSelected)\r\n                {\r\n                    continue;\r\n                }\r\n                if (totalcount > 10000)\r\n                {\r\n                    SubsetPolygonTile des = new SubsetPolygonTile();\r\n                    des.Name = this.Name;\r\n                    des.Descrio = polygon.Description;\r\n                    des.NormalColor = polygon.DES.NormalColor;\r\n                    des.Geometry.Rings.AddRange(templist.ToArray());\r\n                    deset.SectionTiles.Add(des);\r\n                    totalcount = 0;\r\n                    templist.Clear();\r\n                }\r\n                int count = 0;\r\n                PolygonG plg = item.DES.Geometry;\r\n                plg.Attribute = item.DES.Altitude;\r\n                count += item.DES.Geometry.OuterBoundary.Count;\r\n                for (int i = 0; i < item.DES.Geometry.InnerBoundaries.Count; i++)\r\n                {\r\n                    count += item.DES.Geometry.InnerBoundaries[i].Count;\r\n                }\r\n                templist.Add(plg);\r\n                totalcount += count;\r\n            }\r\n            if (templist.Count != 0)\r\n            {\r\n                SubsetPolygonTile des = new SubsetPolygonTile();\r\n                des.Name = this.Name;\r\n                des.Descrio = polygon.Description;\r\n                des.NormalColor = polygon.DES.NormalColor;\r\n                des.Geometry.Rings.AddRange(templist.ToArray());\r\n                deset.SectionTiles.Add(des);\r\n                totalcount = 0;\r\n                templist.Clear();\r\n            }\r\n            if (deset.SectionTiles.Count == 0)\r\n            {\r\n                System.Windows.Forms.MessageBox.Show(\"没有选中任何目标\");\r\n                return;\r\n            }\r\n            base.CreateNewElement(polygon.Window, deset);\r\n        }\r\n    }\r\n```\r\n### 示例代码3：线图层转换为线集合对象\r\n```csharp\r\npublic class tMultiLineToSingleLineGroup : mTooler<VSpatialPathLayer>\r\n    {\r\n        public override string Title { get { return \"[转换] PathMeshModel]\"; } }\r\n\r\n\r\n        private EPathMode mPath = EPathMode.Single;\r\n        public override void Process(VSpatialPathLayer line)\r\n        {\r\n            XMultiLinearStringRenderDescription geos = new XMultiLinearStringRenderDescription();\r\n            geos.Name = line.Name;\r\n            geos.Descrio = line.Description;\r\n            geos.NormalColor = line.DES.NormalColor;\r\n            geos.PathMode = this.mPath;\r\n            foreach (var item in line.Childrens.Values)\r\n            {\r\n                if (!item.IsSelected)\r\n                {\r\n                    continue;\r\n                }\r\n                item.DES.Geometry.Attribute = item.DES.Altitude;\r\n                geos.Geometry.LineStringList.Add(item.DES.Geometry);\r\n            }\r\n\r\n            this.CreateNewElement(line.Window, geos);\r\n        }\r\n        protected override void DrawInner()\r\n        {\r\n            ImGui.InputText(\"名称\", ref this.m_Name, 32);\r\n            ImGuiHelper.Combox<EPathMode>(\"样式\", ref this.mPath);\r\n        }\r\n    }\r\n```\r\n### 示例代码4：面对象本地化信息输出\r\n ```csharp\r\npublic class tPolygonToLocationPatch : mTooler<IPolygonEditor>\r\n    {\r\n        public override string Title { get { return \"[创建] 本地化信息\"; } }\r\n\r\n        private string regionname = \"北京\";\r\n        private string regiondescription = \"未描述\";\r\n        private string RMark = \"XSCOPE\";\r\n\r\n        public tPolygonToLocationPatch() : base()\r\n        {\r\n\r\n        }\r\n        public override void DrawContent()\r\n        {\r\n            ImGui.BulletText(this.Title);\r\n            ImGui.Separator();\r\n            this.DrawInner();\r\n        }\r\n        protected override void DrawInner()\r\n        {\r\n            ImGui.TextDisabled(\"生成本地化信息文件\");\r\n            ImGui.InputText(\"名称\", ref this.regionname, 32);\r\n            ImGui.InputText(\"描述\", ref this.regiondescription, 32);\r\n            ImGui.InputText(\"产品代号\", ref this.RMark, 32);\r\n            if (ImGui.Button(\"生成文件\", this.bntsize))\r\n            { \r\n            }\r\n            ImGui.Separator();\r\n            if (ImGui.Button(\"导出VPLG文件\"))\r\n            {\r\n                PolygonG pg = this.fTarget.PLG.ToPolygonG();\r\n                Gaiaxis.DirectX11.Gui.ImGuiSaveFileBrowser.Instance.ShowPopupModal(\"导出PolygonG文件(*.vplg)\", new string[] { \"*.vplg\" }, (fileName) =>\r\n                {\r\n                    Gaiaxis.IO.GaeaSerializer<PolygonG>.Save(fileName, pg);\r\n                });\r\n            }\r\n            ImGui.SameLine();\r\n            if (ImGui.Button(\"复制为字符串\"))\r\n            {\r\n                string uriString = Gaiaxis.Geographics.Utilities.ShapeToBase64String.ToBase64String(this.fTarget.PLG);\r\n                Clipboard.SetDataObject(uriString, true);\r\n            }\r\n            Gaiaxis.DirectX11.Gui.ImGuiSaveFileBrowser.Instance.DrawPopup();\r\n        }\r\n    }\r\n```\r\n \r\n', NULL, 0, '2020-05-27 20:36:00.000000', '2024-04-09 13:51:56.190518', NULL);
INSERT INTO `article` VALUES (10, '如何编写BLOG', 'title: 如何编写BLOG\r\nauthor: maolei\r\ntags:\r\n  - hexo\r\ncategories:\r\n  - 网站\r\ndate: 2020-05-18 12:47:00\r\n---\r\n语法参考:http://www.mdeditor.com/\r\n\r\n上传图片:(直接复制图片内容,然后粘贴过来)\r\n\r\n![upload successful](/blog/images/pasted-1.png)', NULL, 0, '2020-05-18 12:47:00.000000', '2024-04-09 13:51:56.190518', NULL);
INSERT INTO `article` VALUES (11, '默认标题10', '---\ntitle: 默认标题7\nauthor: admin\ntags: [标签1,标签2]\ncategories: [分类1,分类2]\ndate: 2024-04-09 09:46:04\n---\nfirst100000', NULL, 0, '2024-04-09 09:46:04.000000', '2024-04-09 13:51:56.190518', NULL);
INSERT INTO `article` VALUES (12, '在 Windows 上安装 PowerShell', '---\ntitle: 在 Windows 上安装 PowerShell\nauthor: admin\ntags: [标签1,标签2]\ncategories: [分类1,分类2]\ndate: 2024-04-09 14:09:12\n---\n\n\n有多种方法可以在 Windows 中安装 PowerShell。 每种安装方法旨在支持不同的方案和工作流。 选择最符合需求的方法。\n\n- [Winget](https://learn.microsoft.com/zh-cn/powershell/scripting/install/installing-powershell-on-windows?view=powershell-7.2#winget) - 在 Windows 客户端上安装 PowerShell 的建议方法\n\n- [MSI 包](https://learn.microsoft.com/zh-cn/powershell/scripting/install/installing-powershell-on-windows?view=powershell-7.2#msi) - Windows Server 和企业部署方案的最佳选择\n\n- ZIP 包\n\n  -“旁加载”或安装多个版本的最简单方法\n\n  - 将此方法用于 Windows Nano Server、Windows IoT 和基于 Arm 的系统\n\n- [.NET 全局工具](https://learn.microsoft.com/zh-cn/powershell/scripting/install/installing-powershell-on-windows?view=powershell-7.2#dotnet) - 非常适用于安装和使用其他全局工具的 .NET 开发人员\n\n- [Microsoft Store 包](https://learn.microsoft.com/zh-cn/powershell/scripting/install/installing-powershell-on-windows?view=powershell-7.2#msstore) - 适用于 PowerShell 临时用户进行安装的一种简单方法，但有一些限制\n\n 备注\n\n本文中的安装命令适用于最新稳定版的 PowerShell。 若要安装不同版本的 PowerShell，请调整命令以匹配所需的版本。 以下链接会将你定向到 GitHub 上 PowerShell 存储库中每个版本的发布页面。\n\n- 稳定版：https://aka.ms/powershell-release?tag=stable\n- LTS 版本：https://aka.ms/powershell-release?tag=lts\n- 预览版：https://aka.ms/powershell-release?tag=preview\n\n可在“版本”页的“资产”部分中找到每个包的下载链接。 由于“资产” 部分可能处于折叠状态，因此可能需要单击展开它。\n\n\n\n## 使用 Winget 安装 PowerShell（推荐）\n\nWindows 包管理器 Winget 是一种命令行工具，用户可以使用它在 Windows 客户端计算机上查找、安装、升级、删除和配置应用程序。 此工具是 Windows 程序包管理器服务的客户端接口。 默认情况下，`winget` 命令行工具作为应用安装程序与 Windows 11 和现代版本的 Windows 10 捆绑在一起。\n\n 备注\n\n若要查看系统要求列表和安装说明，请参阅 [winget](https://learn.microsoft.com/zh-cn/windows/package-manager/winget) 文档。 `Winget` 当前未在 Windows 服务器上运行。\n\n通过以下命令，可使用已发布的 `winget` 包安装 PowerShell：\n\n搜索最新版本的 PowerShell\n\nPowerShell\n\n```powershell\nwinget search Microsoft.PowerShell\n```\n\nOutput\n\n```Output\nName               Id                           Version   Source\n-----------------------------------------------------------------\nPowerShell         Microsoft.PowerShell         7.4.1.0   winget\nPowerShell Preview Microsoft.PowerShell.Preview 7.4.0.101 winget\n```\n\n使用 `id` 参数安装 PowerShell 或 PowerShell 预览版\n\nPowerShell\n\n```powershell\nwinget install --id Microsoft.Powershell --source winget\nwinget install --id Microsoft.Powershell.Preview --source winget\n```\n\n 备注\n\n在使用 X86 或 X64 处理器的 Windows 系统上，`winget` 安装 MSI 包。 在使用 Arm64 处理器的系统上，`winget` 安装 Microsoft Store (MSIX) 包。 有关详细信息，请参阅 [从 Microsoft Store 安装](https://learn.microsoft.com/zh-cn/powershell/scripting/install/installing-powershell-on-windows?view=powershell-7.2#msstore)。\n\n\n\n## 安装 MSI 包\n\n若要在 Windows 上安装 PowerShell，请使用以下链接从 GitHub 下载安装包。\n\n- [PowerShell-7.4.1-win-x64.msi](https://github.com/PowerShell/PowerShell/releases/download/v7.4.1/PowerShell-7.4.1-win-x64.msi)\n- [PowerShell-7.4.1-win-x86.msi](https://github.com/PowerShell/PowerShell/releases/download/v7.4.1/PowerShell-7.4.1-win-x86.msi)\n\n下载后，双击安装程序文件并按照提示进行操作。\n\n安装程序在 Windows“开始”菜单中创建一个快捷方式。\n\n- 默认情况下，包安装位置为 `$env:ProgramFiles\\PowerShell\\<version>`\n- 可以通过“开始”菜单或 `$env:ProgramFiles\\PowerShell\\<version>\\pwsh.exe` 启动 PowerShell\n\n 备注\n\nPowerShell 7.4 安装到新目录，并与 Windows PowerShell 5.1 并行运行。 PowerShell 7.4 是会删除旧版 PowerShell 7 的就地升级。 PowerShell 的预览版可以与其他版本的 PowerShell 并行安装。\n\n- PowerShell 7.4 安装到 `$env:ProgramFiles\\PowerShell\\7`\n- `$env:ProgramFiles\\PowerShell\\7` 文件夹已添加到 `$env:PATH`\n\n如果需要与其他版本并行运行 PowerShell 7.4，请使用 [ZIP 安装](https://learn.microsoft.com/zh-cn/powershell/scripting/install/installing-powershell-on-windows?view=powershell-7.2#zip)方法将其他版本安装到其他文件夹。\n\n\n\n### PowerShell 7.2 及更高版本中对 Microsoft 更新的支持\n\nPowerShell 7.2 及更高版本支持 Microsoft 更新。 启用此功能时，你将在传统 Microsoft 更新 (MU) 管理流中获得最新的 PowerShell 7 更新，无论是包含适用于企业的 Windows 更新、WSUS、Microsoft Endpoint Configuration Manager，还是包含设置中的交互式 MU 对话框。\n\nPowerShell MSI 包包含以下命令行选项：\n\n- ```\n  USE_MU\n  ```\n\n   \n\n  \\- 该属性有两个可能值：\n\n  - `1`（默认）- 选择通过 Microsoft 更新、WSUS 或 Configuration Manager 进行更新\n  - `0` - 不选择通过 Microsoft 更新、WSUS 或 Configuration Manager 进行更新\n\n- ```\n  ENABLE_MU\n  ```\n\n  - `1`（默认）- 选择加入使用 Microsoft 更新进行自动更新\n  - `0` - 不选择使用 Microsoft 更新\n\n 备注\n\n可能已在之前的安装或手动配置中设置了启用更新。 使用 `ENABLE_MU=0` 并不会删除现有设置。 此外，此设置可由管理员控制的“组策略”设置管理。\n\n有关详细信息，请参阅 [PowerShell Microsoft 更新常见问题解答](https://learn.microsoft.com/zh-cn/powershell/scripting/install/microsoft-update-faq?view=powershell-7.2)。\n\n\n\n### 从命令行安装 MSI 包\n\n可以通过命令行安装 MSI 包，这样管理员能够在没有用户交互的情况下部署包。 MSI 包中有下列控制安装选项的属性：\n\n- `ADD_EXPLORER_CONTEXT_MENU_OPENPOWERSHELL` - 此属性控制用于将 `Open PowerShell` 项添加到 Windows 资源管理器中的上下文菜单的选项。\n\n- `ADD_FILE_CONTEXT_MENU_RUNPOWERSHELL` - 此属性控制用于将 `Run with PowerShell` 项添加到 Windows 资源管理器中的上下文菜单的选项。\n\n- `ENABLE_PSREMOTING` - 此属性控制用于在安装过程中启用 PowerShell 远程处理的选项。\n\n- `REGISTER_MANIFEST` - 此属性控制用于注册 Windows 事件日志记录清单的选项。\n\n- `ADD_PATH` - 此属性控制用于将 PowerShell 添加到 Windows PATH 环境变量的选项。\n\n- `DISABLE_TELEMETRY` - 此属性通过设置 `POWERSHELL_TELEMETRY_OPTOUT` 环境变量来控制用于禁用 PowerShell 遥测的选项。\n\n- ```\n  INSTALLFOLDER\n  ```\n\n   \n\n  \\- 此属性控制安装目录。 默认为\n\n   \n\n  ```\n  $env:ProgramFiles\\PowerShell\\\n  ```\n\n  。 这是安装程序创建版本控制子文件夹的位置。 无法更改版本控制子文件夹的名称。\n\n  - 对于当前版本，版本控制子文件夹为 `7`\n  - 对于预览版本，版本控制子文件夹为 `7-preview`\n\n下面的示例展示了如何在启用所有安装选项的情况下无提示安装 PowerShell。\n\nPowerShell\n\n```powershell\nmsiexec.exe /package PowerShell-7.4.1-win-x64.msi /quiet ADD_EXPLORER_CONTEXT_MENU_OPENPOWERSHELL=1 ADD_FILE_CONTEXT_MENU_RUNPOWERSHELL=1 ENABLE_PSREMOTING=1 REGISTER_MANIFEST=1 USE_MU=1 ENABLE_MU=1 ADD_PATH=1\n```\n\n有关 `Msiexec.exe` 命令行选项的完整列表，请参阅[命令行选项](https://learn.microsoft.com/zh-cn/windows/desktop/Msi/command-line-options)。\n\n\n\n## 安装 ZIP 包\n\n提供有 PowerShell 二进制 ZIP 存档，从而支持高级部署方案。 从[当前版本](https://aka.ms/powershell-release?tag=stable)页下载以下 ZIP 存档之一。\n\n- [PowerShell-7.4.1-win-x64.zip](https://github.com/PowerShell/PowerShell/releases/download/v7.4.1/PowerShell-7.4.1-win-x64.zip)\n- [PowerShell-7.4.1-win-x86.zip](https://github.com/PowerShell/PowerShell/releases/download/v7.4.1/PowerShell-7.4.1-win-x86.zip)\n- [PowerShell-7.4.1-win-arm64.zip](https://github.com/PowerShell/PowerShell/releases/download/v7.4.1/PowerShell-7.4.1-win-arm64.zip)\n\n根据该文件的下载方式，你可能需要使用 `Unblock-File` cmdlet 解锁。 将内容解压到你选择的位置，然后从该位置运行 `pwsh.exe`。 与安装 MSI 包不一样，安装 ZIP 存档不会检查先决条件。 为了让使用 WSMan 的远程处理能够正常运行，请确保已满足[先决条件](https://learn.microsoft.com/zh-cn/powershell/scripting/install/installing-powershell-on-windows?view=powershell-7.2#powershell-remoting)。\n\n使用此方法在类似于 Microsoft Surface Pro X 的计算机上安装基于 ARM 的 PowerShell 版本。为获得最佳结果，请将 PowerShell 安装到 `$env:ProgramFiles\\PowerShell\\7` 文件夹。\n\n\n\n## 作为 .NET 全局工具安装\n\n如果你已安装 [.NET Core SDK](https://learn.microsoft.com/zh-cn/dotnet/core/sdk)，则可以安装 PowerShell 作为 [.NET 全局工具](https://learn.microsoft.com/zh-cn/dotnet/core/tools/global-tools)。\n\n\n\n```\ndotnet tool install --global PowerShell\n```\n\ndotnet 工具安装程序将 `$HOME\\.dotnet\\tools` 添加到 `$env:PATH` 环境变量中。 不过，当前运行的 shell 没有更新后的 `$env:PATH`。 若要从新 shell 启动 PowerShell，可以键入“`pwsh`”。\n\n\n\n## 从 Microsoft Store 安装\n\n可在 Microsoft Store 中安装 PowerShell。 你可以在 [Microsoft Store](https://www.microsoft.com/store/apps/9MZ1SNWT0N5D) 网站上或在 Windows 应用商店应用程序中找到 PowerShell 版本。\n\nMicrosoft Store 包的权益：\n\n- 直接内置于 Windows 的自动更新\n- 与其他软件分发机制（如 Intune 和 Configuration Manager）集成\n- 可以使用 x86、x64 或 Arm64 处理器在 Windows 系统上安装\n\n\n\n### 已知的限制\n\n默认情况下，Windows 应用商店包在应用程序沙盒中运行，后者用于虚拟化对某些文件系统和注册表位置的访问。 对虚拟化文件和注册表位置的更改不会在应用程序沙盒外部保留。\n\n此沙盒会阻止对应用程序的根文件夹进行的所有更改。 不能修改存储在 `$PSHOME` 中的任何系统级配置设置。 其中包括 WSMAN 配置。 这可以防止远程会话连接到 PowerShell 的基于应用商店的安装。 支持用户级配置和 SSH 远程处理。\n\n以下命令需要写入 `$PSHOME`。 PowerShell 的 Microsoft Store 实例中不支持这些命令。\n\n- `Register-PSSessionConfiguration`\n- `Update-Help -Scope AllUsers`\n- `Enable-ExperimentalFeature -Scope AllUsers`\n- `Set-ExecutionPolicy -Scope LocalMachine`\n\n有关详细信息，请参阅[了解打包的桌面应用如何在 Windows 上运行](https://learn.microsoft.com/zh-cn/windows/msix/desktop/desktop-to-uwp-behind-the-scenes)。\n\n\n\n### PowerShell 7.2 的更改\n\n现在从 PowerShell 7.2 开始，文件和注册表虚拟化中免除了 PowerShell 包。 现在，对虚拟化文件和注册表位置的更改会在应用程序沙盒外部保留。 不过，仍会阻止对应用程序根文件夹所做的更改。\n\n 重要\n\n要使此例外生效，你必须在 Windows 1903 或更高版本上运行。\n\n\n\n## 安装预览版本\n\nPowerShell 7 的预览版安装到 `$env:ProgramFiles\\PowerShell\\7-preview`，这样它们可以与 PowerShell 的非预览版并行运行。 PowerShell 7.4 是下一个预览版本。\n\n\n\n## 升级现有安装\n\n若要在升级时获得最佳结果，应使用首次安装 PowerShell 时使用的相同安装方法。 如果不确定 PowerShell 的安装方式，可以检查 `$PSHOME` 变量的值，该变量始终指向包含当前会话运行的 PowerShell 的目录。\n\n- 如果值为 `$HOME\\.dotnet\\tools`，则 PowerShell 随 [.NET Global 工具](https://learn.microsoft.com/zh-cn/powershell/scripting/install/installing-powershell-on-windows?view=powershell-7.2#dotnet)一起安装。\n- 如果值为 `$Env:ProgramFiles\\PowerShell\\7`，则 PowerShell 在使用 X86 或 x64 处理器的计算机上安装为 [MSI 包](https://learn.microsoft.com/zh-cn/powershell/scripting/install/installing-powershell-on-windows?view=powershell-7.2#msi)或与 [Winget 包](https://learn.microsoft.com/zh-cn/powershell/scripting/install/installing-powershell-on-windows?view=powershell-7.2#winget)一起安装。\n- 如果值以 `$Env:ProgramFiles\\WindowsApps\\` 开头，则 PowerShell 在使用 ARM 处理器的计算机上安装为 [Microsoft Store 包](https://learn.microsoft.com/zh-cn/powershell/scripting/install/installing-powershell-on-windows?view=powershell-7.2#msstore)或与 [Winget](https://learn.microsoft.com/zh-cn/powershell/scripting/install/installing-powershell-on-windows?view=powershell-7.2#winget) 一起安装。\n- 如果值是任何其他值，则可能是 PowerShell 安装为 [ZIP 包](https://learn.microsoft.com/zh-cn/powershell/scripting/install/installing-powershell-on-windows?view=powershell-7.2#zip)。\n\n如果是通过 MSI 包安装的，则该信息还会显示在**“程序和功能”**控制面板中。\n\n为确定是否可以使用 Winget 升级 PowerShell，请运行以下命令：\n\nPowerShell\n\n```powershell\nwinget list --name PowerShell --upgrade-available\n```\n\n如果有可用的升级，输出会指示最新的可用版本。\n\n 备注\n\n升级时，PowerShell 不会从 LTS 版本升级到非 LTS 版本。 它仅升级到最新版本的 LTS，例如，从 7.2.3 升级到 7.2.18。 若要从 LTS 版本升级到较新的稳定版本或下一个 LTS 版本，需要使用新版本的 MSI 来安装该版本。\n\n当安装的版本不是 LTS 版本时，PowerShell 将升级到最新的稳定版本。\n\n\n\n## Windows 10 IoT 企业版部署\n\nWindows 10 IoT 企业版随附 Windows PowerShell，可用来部署 PowerShell 7。\n\nPowerShell\n\n```powershell\n# Replace the placeholder information for the following variables:\n$deviceip = \'<device ip address\'\n$zipfile = \'PowerShell-7.4.1-win-arm64.zip\'\n$downloadfolder = \'u:\\users\\administrator\\Downloads\'  # The download location is local to the device.\n    # There should be enough  space for the zip file and the unzipped contents.\n\n# Create PowerShell session to target device\nSet-Item -Path WSMan:\\localhost\\Client\\TrustedHosts $deviceip\n$S = New-PSSession -ComputerName $deviceIp -Credential Administrator\n# Copy the ZIP package to the device\nCopy-Item $zipfile -Destination $downloadfolder -ToSession $S\n\n#Connect to the device and expand the archive\nEnter-PSSession $S\nSet-Location u:\\users\\administrator\\Downloads\nExpand-Archive .\\PowerShell-7.4.1-win-arm64.zip\n\n# Set up remoting to PowerShell 7\nSet-Location .\\PowerShell-7.4.1-win-arm64\n# Be sure to use the -PowerShellHome parameter otherwise it tries to create a new\n# endpoint with Windows PowerShell 5.1\n.\\Install-PowerShellRemoting.ps1 -PowerShellHome .\n```\n\n设置 PowerShell 远程处理时，你收到一条错误消息，并与设备断开连接。 PowerShell 必须重启 WinRM。 现在可以连接到设备上的 PowerShell 7 终结点。\n\nPowerShell\n\n```powershell\n# Be sure to use the -Configuration parameter. If you omit it, you connect to Windows PowerShell 5.1\nEnter-PSSession -ComputerName $deviceIp -Credential Administrator -Configuration PowerShell.7.4.1\n```\n\n\n\n## Windows 10 IoT 核心版部署\n\n当你添加 IOT_POWERSHELL 功能后，Windows 10 IoT 核心版便会添加 Windows PowerShell，我们可以使用它来部署 PowerShell 7。 对于 IoT 核心版，还可以遵循为 Windows 10 IoT 企业版定义的步骤。\n\n若要在随附映像中添加最新的 PowerShell，请使用 [Import-PSCoreRelease](https://github.com/ms-iot/iot-adk-addonkit/blob/master/Tools/IoTCoreImaging/Docs/Import-PSCoreRelease.md#Import-PSCoreRelease) 命令在工作区域中添加包，然后将 OPENSRC_POWERSHELL 功能添加到映像中。\n\n 备注\n\n对于 ARM64 体系结构，在你添加 IOT_POWERSHELL 功能后，它不会添加 Windows PowerShell。 因此，基于 zip 的安装将不起作用。 需要使用 `Import-PSCoreRelease` 命令将其添加到映像中。\n\n\n\n## 在 Nano Server 上进行部署\n\n为了更好地理解这些说明，假定 Nano Server 是已运行 PowerShell 版本的“无外设”操作系统。 有关详细信息，请参阅 [Nano Server 映像生成器](https://learn.microsoft.com/zh-cn/windows-server/get-started/deploy-nano-server)文档。\n\n可以使用两种不同的方法来部署 PowerShell 二进制文件。\n\n1. 脱机 - 安装 Nano Server VHD，并将 zip 文件的内容解压到安装映像中的所选位置。\n2. 联机 - 通过 PowerShell 会话传输 zip 文件，并在所需位置中将其解压。\n\n在这两种情况下，都需要 [Windows x64 ZIP 版本包](https://github.com/PowerShell/PowerShell/releases/download/v7.4.1/PowerShell-7.4.1-win-x64.zip)。 在 PowerShell 的“管理员”实例中运行命令。\n\n\n\n### PowerShell 脱机部署\n\n1. 使用常用 zip 实用工具将包解压到已安装的 Nano Server 映像中的目录。\n2. 卸载映像并启动。\n3. 连接到 Windows PowerShell 的内置实例。\n4. 按照说明使用[“另一种实例技术”](https://learn.microsoft.com/zh-cn/powershell/scripting/learn/remoting/wsman-remoting-in-powershell-core?view=powershell-7.2#executed-by-another-instance-of-powershell-on-behalf-of-the-instance-that-it-will-register)创建远程处理终结点。\n\n\n\n### PowerShell 联机部署\n\n若要将 PowerShell 部署到 Nano Server，请按照以下步骤操作。\n\nPowerShell\n\n```powershell\n# Replace the placeholder information for the following variables:\n$ipaddr = \'<Nano Server IP address>\'\n$credential = Get-Credential # <An Administrator account on the system>\n$zipfile = \'PowerShell-7.4.1-win-x64.zip\'\n# Connect to the built-in instance of Windows PowerShell\n$session = New-PSSession -ComputerName $ipaddr -Credential $credential\n# Copy the file to the Nano Server instance\nCopy-Item $zipfile c:\\ -ToSession $session\n# Enter the interactive remote session\nEnter-PSSession $session\n# Extract the ZIP file\nExpand-Archive -Path C:\\PowerShell-7.4.1-win-x64.zip -DestinationPath \'C:\\Program Files\\PowerShell 7\'\n```\n\n如果需要基于 WSMan 的远程处理，请按照说明使用[“另一种实例技术”](https://learn.microsoft.com/zh-cn/powershell/scripting/learn/remoting/wsman-remoting-in-powershell-core?view=powershell-7.2#executed-by-another-instance-of-powershell-on-behalf-of-the-instance-that-it-will-register)创建远程处理终结点。\n\n\n\n## PowerShell 远程处理\n\nPowerShell 同时支持采用 WSMan 和 SSH 的 PowerShell 远程处理协议 (PSRP)。 有关详细信息，请参阅：\n\n- [在 PowerShell 中进行 SSH 远程处理](https://learn.microsoft.com/zh-cn/powershell/scripting/learn/remoting/ssh-remoting-in-powershell-core?view=powershell-7.2)\n- [在 PowerShell 中进行 WSMan 远程处理](https://learn.microsoft.com/zh-cn/powershell/scripting/learn/remoting/wsman-remoting-in-powershell-core?view=powershell-7.2)\n\n必须满足以下先决条件才能在较低版本的 Windows 上通过 WSMan 启用 PowerShell 远程处理。\n\n- 安装 Windows Management Framework (WMF) 5.1（根据需要）。 有关 WMF 的详细信息，请参阅 [WMF 概述](https://learn.microsoft.com/zh-cn/powershell/scripting/wmf/overview)。\n- 在低于 Windows 10 的 Windows 版本上安装[通用 C 运行时](https://www.microsoft.com/download/details.aspx?id=50410)。 可以通过直接下载或 Windows 更新来获取它。 完全修补的系统已安装此包。', NULL, 0, '2024-04-09 14:13:48.509450', '2024-04-09 14:13:48.509450', NULL);

SET FOREIGN_KEY_CHECKS = 1;
